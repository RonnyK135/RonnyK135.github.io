<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yue Yong&#39;s Blog</title>
  
  <subtitle>众里寻他千百度，蓦然回首，那人却在灯火阑珊处</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.yueyongblog.com/"/>
  <updated>2018-07-22T04:46:00.727Z</updated>
  <id>https://www.yueyongblog.com/</id>
  
  <author>
    <name>Yong YUE</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅显易懂的grep命令详解</title>
    <link href="https://www.yueyongblog.com/grep-command.html"/>
    <id>https://www.yueyongblog.com/grep-command.html</id>
    <published>2018-07-22T04:18:00.000Z</published>
    <updated>2018-07-22T04:46:00.727Z</updated>
    
    <content type="html"><![CDATA[<p>grep (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><p><img src="https://upload-images.jianshu.io/upload_images/3275724-7bf902884b0f7d91.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="small_linux_grep_command.jpg"></p><a id="more"></a><p>Unix的grep家族包括grep、egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符， fgrep就是fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。linux使用GNU版本的grep。它功能更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。</p><h4 id="grep常用用法"><a href="#grep常用用法" class="headerlink" title="grep常用用法"></a>grep常用用法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# grep [-acinv] [--color=auto] &apos;搜寻字符串&apos; filename</span><br><span class="line">选项与参数：</span><br><span class="line">-a ：将 binary 文件以 text 文件的方式搜寻数据</span><br><span class="line">-c ：计算找到 &apos;搜寻字符串&apos; 的次数</span><br><span class="line">-i ：忽略大小写的不同，所以大小写视为相同</span><br><span class="line">-n ：顺便输出行号</span><br><span class="line">-v ：反向选择，亦即显示出没有 &apos;搜寻字符串&apos; 内容的那一行！</span><br><span class="line">--color=auto ：可以将找到的关键词部分加上颜色的显示喔！</span><br></pre></td></tr></table></figure><p>将/etc/passwd，有出现 root 的行取出来</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># grep root /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat /etc/passwd | grep root </span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br></pre></td></tr></table></figure><p>将/etc/passwd，有出现 root 的行取出来,同时显示这些行在/etc/passwd的行号</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># grep -n root /etc/passwd</span><br><span class="line">1:root:x:0:0:root:/root:/bin/bash</span><br><span class="line">30:operator:x:11:0:operator:/root:/sbin/nologin</span><br></pre></td></tr></table></figure><p>在关键字的显示方面，grep 可以使用 –color=auto 来将关键字部分使用颜色显示。 这可是个很不错的功能啊！但是如果每次使用 grep 都得要自行加上 –color=auto 又显的很麻烦～ 此时那个好用的 alias 就得来处理一下啦！你可以在 ~/.bashrc 内加上这行：『alias grep=’grep –color=auto’』再以『 source ~/.bashrc 』来立即生效即可喔！ 这样每次运行 grep 他都会自动帮你加上颜色显示啦</p><p>将/etc/passwd，将没有出现 root 的行取出来</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># grep -v root /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br></pre></td></tr></table></figure><p>将/etc/passwd，将没有出现 root 和nologin的行取出来</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># grep -v root /etc/passwd | grep -v nologin</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br></pre></td></tr></table></figure><p>用 dmesg 列出核心信息，再以 grep 找出内含 eth 那行,要将捉到的关键字显色，且加上行号来表示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# dmesg | grep -n --color=auto &apos;eth&apos;</span><br><span class="line">247:eth0: RealTek RTL8139 at 0xee846000, 00:90:cc:a6:34:84, IRQ 10</span><br><span class="line">248:eth0: Identified 8139 chip type &apos;RTL-8139C&apos;</span><br><span class="line">294:eth0: link up, 100Mbps, full-duplex, lpa 0xC5E1305:eth0: no IPv6 routers present</span><br><span class="line"># 你会发现除了 eth 会有特殊颜色来表示之外，最前面还有行号喔！</span><br></pre></td></tr></table></figure><p>在关键字的显示方面，grep 可以使用 –color=auto 来将关键字部分使用颜色显示。 这可是个很不错的功能啊！但是如果每次使用 grep 都得要自行加上 –color=auto 又显的很麻烦～ 此时那个好用的 alias 就得来处理一下啦！你可以在 ~/.bashrc 内加上这行：『alias grep=’grep –color=auto’』再以『 source ~/.bashrc 』来立即生效即可喔！ 这样每次运行 grep 他都会自动帮你加上颜色显示啦</p><p>用 dmesg 列出核心信息，再以 grep 找出内含 eth 那行,在关键字所在行的前两行与后三行也一起捉出来显示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# dmesg | grep -n -A3 -B2 --color=auto &apos;eth&apos;</span><br><span class="line">245-PCI: setting IRQ 10 as level-triggered</span><br><span class="line">246-ACPI: PCI Interrupt 0000:00:0e.0[A] -&gt; Link [LNKB] ...</span><br><span class="line">247:eth0: RealTek RTL8139 at 0xee846000, 00:90:cc:a6:34:84, IRQ 10</span><br><span class="line">248:eth0: Identified 8139 chip type &apos;RTL-8139C&apos;</span><br><span class="line">249-input: PC Speaker as /class/input/input2</span><br><span class="line">250-ACPI: PCI Interrupt 0000:00:01.4[B] -&gt; Link [LNKB] ...</span><br><span class="line">251-hdb: ATAPI 48X DVD-ROM DVD-R-RAM CD-R/RW drive, 2048kB Cache, UDMA(66)</span><br><span class="line"># 如上所示，你会发现关键字 247 所在的前两行及 248 后三行也都被显示出来！# 这样可以让你将关键字前后数据捉出来进行分析啦！</span><br></pre></td></tr></table></figure><h5 id="根据文件内容递归查找目录"><a href="#根据文件内容递归查找目录" class="headerlink" title="根据文件内容递归查找目录"></a>根据文件内容递归查找目录</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># grep ‘energywise’ *           #在当前目录搜索带&apos;energywise&apos;行的文件</span><br><span class="line"># grep -r ‘energywise’ *        #在当前目录及其子目录下搜索&apos;energywise&apos;行的文件</span><br><span class="line"># grep -l -r ‘energywise’ *     #在当前目录及其子目录下搜索&apos;energywise&apos;行的文件，但是不显示匹配的行，只显示匹配的文件</span><br></pre></td></tr></table></figure><p>这几个命令很实用，是查找文件的利器。</p><h4 id="grep与正则表达式"><a href="#grep与正则表达式" class="headerlink" title="grep与正则表达式"></a>grep与正则表达式</h4><h5 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h5><p>字符类的搜索：如果我想要搜寻 test 或 taste 这两个单词时，可以发现到，其实她们有共通的 ‘t?st’ 存在～这个时候，我可以这样来搜寻：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;t[ae]st&apos; regular_express.txt</span><br><span class="line">8:I can&apos;t finish the test.9:Oh! The soup taste good.</span><br></pre></td></tr></table></figure><p>其实 [] 里面不论有几个字节，他都谨代表某『一个』字节， 所以，上面的例子说明了，我需要的字串是『tast』或『test』两个字串而已！</p><p>字符类的反向选择 [^] ：如果想要搜索到有 oo 的行，但不想要 oo 前面有 g，如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;[^g]oo&apos; regular_express.txt</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">18:google is the best tools for search keyword.</span><br><span class="line">19:goooooogle yes!</span><br></pre></td></tr></table></figure><p>第 2,3 行没有疑问，因为 foo 与 Foo 均可被接受！</p><p>但是第 18 行明明有 google 的 goo 啊～别忘记了，因为该行后面出现了 tool 的 too 啊！所以该行也被列出来～ 也就是说， 18 行里面虽然出现了我们所不要的项目 (goo) 但是由於有需要的项目 (too) ， 因此，是符合字串搜寻的喔！</p><p>至於第 19 行，同样的，因为 goooooogle 里面的 oo 前面可能是 o ，例如： go(ooo)oogle ，所以，这一行也是符合需求的！</p><p>字符类的连续：再来，假设我 oo 前面不想要有小写字节，所以，我可以这样写 [^abcd….z]oo ， 但是这样似乎不怎么方便，由於小写字节的 ASCII 上编码的顺序是连续的， 因此，我们可以将之简化为底下这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;[^a-z]oo&apos; regular_express.txt</span><br><span class="line">3:Football game is not use feet only.</span><br></pre></td></tr></table></figure><p>也就是说，当我们在一组集合字节中，如果该字节组是连续的，例如大写英文/小写英文/数字等等， 就可以使用[a-z],[A-Z],[0-9]等方式来书写，那么如果我们的要求字串是数字与英文呢？ 呵呵！就将他全部写在一起，变成：[a-zA-Z0-9]。</p><p>我们要取得有数字的那一行，就这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;[0-9]&apos; regular_express.txt</span><br><span class="line">5:However, this dress is about $ 3183 dollars.</span><br><span class="line">15:You are the best is mean you are the no. 1.</span><br></pre></td></tr></table></figure><h5 id="行首与行尾字节"><a href="#行首与行尾字节" class="headerlink" title="行首与行尾字节 ^ $"></a>行首与行尾字节 ^ $</h5><p>行首字符：如果我想要让 the 只在行首列出呢？ 这个时候就得要使用定位字节了！我们可以这样做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;^the&apos; regular_express.txt</span><br><span class="line">12:the symbol &apos;*&apos; is represented as start.</span><br></pre></td></tr></table></figure><p>此时，就只剩下第 12 行，因为只有第 12 行的行首是 the 开头啊～此外， 如果我想要开头是小写字节的那一行就列出呢？可以这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;^[a-z]&apos; regular_express.txt</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">4:this dress doesn&apos;t fit me.10:motorcycle is cheap than car.</span><br><span class="line">12:the symbol &apos;*&apos; is represented as start.</span><br><span class="line">18:google is the best tools for search keyword.</span><br><span class="line">19:goooooogle yes!</span><br><span class="line">20:go! go! Let&apos;s go.</span><br></pre></td></tr></table></figure><p>如果我不想要开头是英文字母，则可以是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;^[^a-zA-Z]&apos; regular_express.txt</span><br><span class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span><br><span class="line">21:# I am VBird</span><br></pre></td></tr></table></figure><p>^ 符号，在字符类符号(括号[])之内与之外是不同的！ 在 [] 内代表『反向选择』，在 [] 之外则代表定位在行首的意义！</p><p>那如果我想要找出来，行尾结束为小数点 (.) 的那一行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;\.$&apos; regular_express.txt</span><br><span class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">4:this dress doesn&apos;t fit me.</span><br><span class="line">10:motorcycle is cheap than car.</span><br><span class="line">11:This window is clear.</span><br><span class="line">12:the symbol &apos;*&apos; is represented as start.</span><br><span class="line">15:You are the best is mean you are the no.</span><br><span class="line">16:The world &lt;Happy&gt; is the same with &quot;glad&quot;.</span><br><span class="line">17:I like dog.</span><br><span class="line">18:google is the best tools for search keyword.</span><br><span class="line">20:go! go! Let&apos;s go.</span><br></pre></td></tr></table></figure><p>特别注意到，因为小数点具有其他意义(底下会介绍)，所以必须要使用转义字符()来加以解除其特殊意义！</p><p>找出空白行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;^$&apos; regular_express.txt</span><br><span class="line">22:</span><br></pre></td></tr></table></figure><p>因为只有行首跟行尾 (^$)，所以，这样就可以找出空白行啦！</p><h5 id="任意一个字节-与重复字节"><a href="#任意一个字节-与重复字节" class="headerlink" title="任意一个字节 . 与重复字节 *"></a>任意一个字节 . 与重复字节 *</h5><p>这两个符号在正则表达式的意义如下：</p><p>. (小数点)：代表『一定有一个任意字节』的意思；* (星号)：代表『重复前一个字符， 0 到无穷多次』的意思，为组合形态</p><p>假设我需要找出 g??d 的字串，亦即共有四个字节， 起头是 g 而结束是 d ，我可以这样做：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;g..d&apos; regular_express.txt</span><br><span class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">16:The world &lt;Happy&gt; is the same with &quot;glad&quot;.</span><br></pre></td></tr></table></figure><p>因为强调 g 与 d 之间一定要存在两个字节，因此，第 13 行的 god 与第 14 行的 gd 就不会被列出来啦！</p><p>如果我想要列出有 oo, ooo, oooo 等等的数据， 也就是说，至少要有两个(含) o 以上，该如何是好？</p><p>因为 <em> 代表的是『重复 0 个或多个前面的 RE 字符』的意义， 因此，『o\</em>』代表的是：『拥有空字节或一个 o 以上的字节』，因此，『 grep -n ‘o*’ regular_express.txt 』将会把所有的数据都列印出来终端上！</p><p>当我们需要『至少两个 o 以上的字串』时，就需要 ooo* ，亦即是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;ooo*&apos; regular_express.txt</span><br><span class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">18:google is the best tools for search keyword.</span><br><span class="line">19:goooooogle yes!</span><br></pre></td></tr></table></figure><p>如果我想要字串开头与结尾都是 g，但是两个 g 之间仅能存在至少一个 o ，亦即是 gog, goog, gooog…. 等等，那该如何？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;goo*g&apos; regular_express.txt</span><br><span class="line">18:google is the best tools for search keyword.</span><br><span class="line">19:goooooogle yes!</span><br></pre></td></tr></table></figure><p>如果我想要找出 g 开头与 g 结尾的行，当中的字符可有可无</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;g.*g&apos; regular_express.txt</span><br><span class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span><br><span class="line">14:The gd software is a library for drafting programs.</span><br><span class="line">18:google is the best tools for search keyword.</span><br><span class="line">19:goooooogle yes!</span><br><span class="line">20:go! go! Let&apos;s go.</span><br></pre></td></tr></table></figure><p>因为是代表 g 开头与 g 结尾，中间任意字节均可接受，所以，第 1, 14, 20 行是可接受的喔！ 这个 .* 的 RE 表示任意字符是很常见的.</p><p>如果我想要找出『任意数字』的行？因为仅有数字，所以就成为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;[0-9][0-9]*&apos; regular_express.txt</span><br><span class="line">5:However, this dress is about $ 3183 dollars.</span><br><span class="line">15:You are the best is mean you are the no. 1.</span><br></pre></td></tr></table></figure><h5 id="限定连续-RE-字符范围"><a href="#限定连续-RE-字符范围" class="headerlink" title="限定连续 RE 字符范围 {}"></a>限定连续 RE 字符范围 {}</h5><p>我们可以利用 . 与 RE 字符及 * 来配置 0 个到无限多个重复字节， 那如果我想要限制一个范围区间内的重复字节数呢？</p><p>举例来说，我想要找出两个到五个 o 的连续字串，该如何作？这时候就得要使用到限定范围的字符 {} 了。 但因为 { 与 } 的符号在 shell 是有特殊意义的，因此， 我们必须要使用字符   \ 来让他失去特殊意义才行。 至於 {} 的语法是这样的，假设我要找到两个 o 的字串，可以是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;o\&#123;2\&#125;&apos; regular_express.txt</span><br><span class="line">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">18:google is the best tools for search ke</span><br><span class="line">19:goooooogle yes!</span><br></pre></td></tr></table></figure><p>假设我们要找出 g 后面接 2 到 5 个 o ，然后再接一个 g 的字串，他会是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;go\&#123;2,5\&#125;g&apos; regular_express.txt</span><br><span class="line">18:google is the best tools for search keyword.</span><br></pre></td></tr></table></figure><p>如果我想要的是 2 个 o 以上的 goooo….g 呢？除了可以是 gooo*g ，也可以是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# grep -n &apos;go\&#123;2,\&#125;g&apos; regular_express.txt</span><br><span class="line">18:google is the best tools for search keyword.</span><br><span class="line">19:goooooogle yes!</span><br></pre></td></tr></table></figure><h5 id="扩展grep-grep-E-或者-egrep-："><a href="#扩展grep-grep-E-或者-egrep-：" class="headerlink" title="扩展grep(grep -E 或者 egrep)："></a>扩展grep(grep -E 或者 egrep)：</h5><p>使用扩展grep的主要好处是增加了额外的正则表达式元字符集。</p><p>打印所有包含NW或EA的行。如果不是使用egrep，而是grep，将不会有结果查出。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># egrep &apos;NW|EA&apos; testfile        </span><br><span class="line">northwest       NW      Charles Main        3.0     .98     3       34   </span><br><span class="line">eastern         EA      TB Savage           4.4     .84     5       20</span><br></pre></td></tr></table></figure><p>对于标准grep，如果在扩展元字符前面加\，grep会自动启用扩展选项-E。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#grep &apos;NW\|EA&apos; testfil</span><br><span class="line">enorthwest      NW      Charles Main        3.0     .98     3       34</span><br><span class="line">eastern         EA      TB Savage           4.4     .84     5       20</span><br></pre></td></tr></table></figure><p>搜索所有包含一个或多个3的行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># egrep &apos;3+&apos; testfile# grep -E &apos;3+&apos; testfile# grep &apos;3\+&apos; testfile        </span><br><span class="line">#这3条命令将会搜索所有包含一个或多个3的行</span><br><span class="line">northwest       NW      Charles Main          3.0     .98     3       34</span><br><span class="line">western         WE      Sharon Gray           5.3     .97     5       23</span><br><span class="line">northeast       NE      AM Main Jr.           5.1     .94     3       13</span><br><span class="line">central         CT      Ann Stephens          5.7     .94     5       13</span><br></pre></td></tr></table></figure><p>搜索所有包含0个或1个小数点字符的行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># egrep &apos;2\.?[0-9]&apos; testfile # grep -E &apos;2\.?[0-9]&apos; testfile# grep &apos;2\.\?[0-9]&apos; testfile </span><br><span class="line">#首先含有2字符，其后紧跟着0个或1个点，后面再是0和9之间的数字。</span><br><span class="line"></span><br><span class="line">western         WE       Sharon Gray          5.3     .97     5       23</span><br><span class="line">southwest       SW      Lewis Dalsass         2.7     .8      2       18</span><br><span class="line">eastern         EA       TB Savage             4.4     .84     5       20</span><br></pre></td></tr></table></figure><p>搜索一个或者多个连续的no的行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># egrep &apos;(no)+&apos; testfile# grep -E &apos;(no)+&apos; testfile# grep &apos;\(no\)\+&apos; testfile   #3个命令返回相同结果</span><br><span class="line">northwest       NW      Charles Main        3.0     .98     3       34</span><br><span class="line">northeast       NE       AM Main Jr.        5.1     .94     3       13</span><br><span class="line">north           NO      Margot Weber        4.5     .89     5       9</span><br></pre></td></tr></table></figure><h5 id="不使用正则表达式"><a href="#不使用正则表达式" class="headerlink" title="不使用正则表达式"></a>不使用正则表达式</h5><p>fgrep 查询速度比grep命令快，但是不够灵活：它只能找固定的文本，而不是规则表达式。</p><p>如果你想在一个文件或者输出中找到包含星号字符的行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fgrep  &apos;*&apos; /etc/profilefor i in /etc/profile.d/*.sh ; do</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -F &apos;*&apos; /etc/profilefor i in /etc/profile.d/*.sh ; do</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;grep (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3275724-7bf902884b0f7d91.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;small_linux_grep_command.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.yueyongblog.com/tags/Linux/"/>
    
      <category term="grep" scheme="https://www.yueyongblog.com/tags/grep/"/>
    
  </entry>
  
  <entry>
    <title>如何在Linux中使用awk工具详解</title>
    <link href="https://www.yueyongblog.com/awk-command.html"/>
    <id>https://www.yueyongblog.com/awk-command.html</id>
    <published>2018-07-15T08:13:15.851Z</published>
    <updated>2018-07-15T08:14:36.023Z</updated>
    
    <content type="html"><![CDATA[<p>awk 是一个强大的文本分析工具。它不仅是 Linux 中，也是任何环境中现有的功能最强大的数据处理引擎之一。相对于 grep 的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。</p><p><img src="https://upload-images.jianshu.io/upload_images/3275724-417ad6ad01ebe66d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="small_Awk_command"></p><a id="more"></a><p>当你第一次拿起双手在电脑上使用 awk 命令处理一个或者多个文件的时候，它会依次读取文件的每一行内容, 然后对其进行处理，awk 命令默认从 stdio 标准输入获取文件内容, awk 使用一对单引号来表示 一些可执行的脚本代码，在可执行脚本代码里面，使用一对花括号来表示一段可执行代码块，可以同时存在多个代码块。</p><p> awk 的每个花括号内同时又可以有多个指令，每一个指令用分号分隔，awk 其实就是一个脚本编程语言。说了这么多，你肯定还是一脸的懵逼。你猜对了，上面这些都是废话。先别急，客官请往下看……</p><h4 id="awk-命令的基本格式"><a href="#awk-命令的基本格式" class="headerlink" title="awk 命令的基本格式"></a>awk 命令的基本格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk [options] &apos;program&apos; file</span><br></pre></td></tr></table></figure><p>options 这个表示一些可选的参数选项<br>program 这个表示 awk 的可执行脚本代码，这个是必须要有的。<br>file 这个表示 awk 需要处理的文件，注意是纯文本文件，不是你的 mp3，也不是 mp4 啥的。</p><h4 id="先来一个-awk-的使用例子热热身"><a href="#先来一个-awk-的使用例子热热身" class="headerlink" title="先来一个 awk 的使用例子热热身"></a>先来一个 awk 的使用例子热热身</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print $0&#125;&apos; /etc/passwd</span><br></pre></td></tr></table></figure><p>awk 命令的可执行脚本代码使用单引号括起来，紧接着里面是一对花括号，记住是 “花括号” 不是 “花姑娘”，然后花括号里面就是一些可执行的脚本代码段;<br>当 awk 每读取一行之后，它会依次执行双引号里面的每个脚本代码段，在上面这个例子中， $0 表示当前行。当你执行了上面的命令之后，它会依次将 /etc/passwd 文件的每一行内容打印输出，你一定在想：这有个毛用，用 cat 命令也能搞定。没错！上面这个命令没个毛用，请往下看。</p><h4 id="awk-自定义分隔符"><a href="#awk-自定义分隔符" class="headerlink" title="awk 自定义分隔符"></a>awk 自定义分隔符</h4><p>awk 默认的分割符为空格和制表符，我们可以使用 -F 参数来指定分隔符<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk -F &apos;:&apos; &apos;&#123;print $1&#125;&apos; /etc/passwd</span><br><span class="line">root</span><br><span class="line">bin</span><br><span class="line">daemon</span><br><span class="line">adm</span><br><span class="line">lp</span><br><span class="line">sync</span><br><span class="line">shutdown</span><br><span class="line">halt</span><br><span class="line">mail</span><br><span class="line">operator</span><br><span class="line">games</span><br><span class="line">ftp</span><br><span class="line">nobody</span><br></pre></td></tr></table></figure></p><p>上面的命令将 /etc/passwd 文件中的每一行用冒号 : 分割成多个字段，然后用 print 将第 1 列字段的内容打印输出</p><h4 id="如何在-awk-中同时指定多个分隔符"><a href="#如何在-awk-中同时指定多个分隔符" class="headerlink" title="如何在 awk 中同时指定多个分隔符"></a>如何在 awk 中同时指定多个分隔符</h4><p>比如现在有这样一个文件 some.log 文件内容如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Grape(100g)1980</span><br><span class="line">raisins(500g)1990</span><br><span class="line">plum(240g)1997</span><br><span class="line">apricot(180g)2005</span><br><span class="line">nectarine(200g)2008</span><br></pre></td></tr></table></figure></p><p>现在我们想将上面的 some.log 文件中按照 “水果名称(重量)年份” 来进行分割<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk -F &apos;[()]&apos; &apos;&#123;print $1, $2, $3&#125;&apos; some.log</span><br><span class="line">Grape 100g 1980</span><br><span class="line">raisins 500g 1990</span><br><span class="line">plum 240g 1997</span><br><span class="line">apricot 180g 2005</span><br><span class="line">nectarine 200g 2008</span><br></pre></td></tr></table></figure></p><p>在 -F 参数中使用一对方括号来指定多个分隔符，awk 处理 some.log 文件时就会使用 “(” 和 “)” 来对文件的每一行进行分割。</p><h4 id="awk-内置变量的使用"><a href="#awk-内置变量的使用" class="headerlink" title="awk 内置变量的使用"></a>awk 内置变量的使用</h4><ul><li>$0 这个表示文本处理时的当前行</li><li>$1 表示文本行被分隔后的第 1 个字段列</li><li>$2 表示文本行被分割后的第 2 个字段列</li><li>$3 表示文本行被分割后的第 3 个字段列</li><li>$n 表示文本行被分割后的第 n 个字段列</li><li>NR 表示文件中的行号，表示当前是第几行</li><li>NF 表示文件中的当前行列的个数，类似于 mysql 数据表里面每一条记录有多少个字段。</li><li>FS 表示 awk 的输入分隔符，默认分隔符为空格和制表符，你可以对其进行自定义设置</li><li>OFS 表示 awk 的输出分隔符，默认为空格，你也可以对其进行自定义设置</li><li>FILENAME 表示当前文件的文件名称，如果同时处理多个文件，它也表示当前文件名称</li></ul><p>比如我们有这么一个文本文件 fruit.txt 内容如下，我将用它来向你演示如何使用 awk 命令工具，顺便活跃一下此时尴尬的气氛。。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">peach    100   Mar  1997   China</span><br><span class="line">Lemon    150   Jan  1986   America</span><br><span class="line">Pear     240   Mar  1990   Janpan</span><br><span class="line">avocado  120   Feb  2008   china</span><br></pre></td></tr></table></figure></p><p>我们来瞧一瞧下面这些简单到爆炸的例子，这个表示打印输出文件的每一整行的内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print $0&#125;&apos; fruit.txt</span><br><span class="line">peach    100   Mar  1997   China</span><br><span class="line">Lemon    150   Jan  1986   America</span><br><span class="line">Pear     240   Mar  1990   Janpan</span><br><span class="line">avocado  120   Feb  2008   china</span><br></pre></td></tr></table></figure></p><p>下面这个表示打印输出文件的每一行的第 1 列内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print $1&#125;&apos; fruit.txt</span><br><span class="line">peach</span><br><span class="line">Lemon</span><br><span class="line">Pear</span><br><span class="line">avocado</span><br></pre></td></tr></table></figure></p><p>下面面这个表示打印输出文件的每一行的第 1 列、第 2 列和第 3 列内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print $1, $2, $3&#125;&apos; fruit.txt</span><br><span class="line">peach 100 Mar</span><br><span class="line">Lemon 150 Jan</span><br><span class="line">Pear 240 Mar</span><br><span class="line">avocado 120 Feb</span><br></pre></td></tr></table></figure></p><p>其中加入的逗号表示插入输出分隔符，也就是默认的空格</p><p>文件的每一行的每一列的内容除了可以用 print 命令打印输出以外，还可以对其进行赋值<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;$2 = &quot;***&quot;; print $0&#125;&apos; fruit.txt</span><br><span class="line">peach *** Mar 1997 China</span><br><span class="line">Lemon *** Jan 1986 America</span><br><span class="line">Pear *** Mar 1990 Janpan</span><br><span class="line">avocado *** Feb 2008 china</span><br></pre></td></tr></table></figure></p><p>上面的例子就是表示通过对 $2 变量进行重新赋值，来隐藏每一行的第 2 列内容，并且用星号 * 来代替其输出</p><p>在参数列表中加入一些字符串或者转义字符之类的东东<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print $1 &quot;\t&quot; $2 &quot;\t&quot; $3&#125;&apos; fruit.txt</span><br><span class="line">peach      100      Mar</span><br><span class="line">Lemon    150      Jan</span><br><span class="line">Pear        240     Mar</span><br><span class="line">avocado 120      Feb</span><br></pre></td></tr></table></figure></p><p>像上面这样，你可以在 print的参数列表中加入一些字符串或者转义字符之类的东东，让输出的内容格式更漂亮，但一定要记住要使用双引号。</p><h4 id="awk-内置-NR-变量表示每一行的行号"><a href="#awk-内置-NR-变量表示每一行的行号" class="headerlink" title="awk 内置 NR 变量表示每一行的行号"></a>awk 内置 NR 变量表示每一行的行号</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print NR &quot;\t&quot; $0&#125;&apos; fruit.txt</span><br><span class="line">1   peach    100   Mar  1997   China</span><br><span class="line">2   Lemon    150   Jan  1986   America</span><br><span class="line">3   Pear     240   Mar  1990   Janpan</span><br><span class="line">4   avocado  120   Feb  2008   china</span><br></pre></td></tr></table></figure><h4 id="awk-内置-NF-变量表示每一行的列数"><a href="#awk-内置-NF-变量表示每一行的列数" class="headerlink" title="awk 内置 NF 变量表示每一行的列数"></a>awk 内置 NF 变量表示每一行的列数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print NF &quot;\t&quot; $0&#125;&apos; fruit.txt</span><br><span class="line">5   peach    100   Mar  1997   China</span><br><span class="line">5   Lemon    150   Jan  1986   America</span><br><span class="line">5   Pear     240   Mar  1990   Janpan</span><br><span class="line">5   avocado  120   Feb  2008   china</span><br></pre></td></tr></table></figure><h4 id="awk-中-NF-变量的使用"><a href="#awk-中-NF-变量的使用" class="headerlink" title="awk 中 $NF 变量的使用"></a>awk 中 $NF 变量的使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print $NF&#125;&apos; fruit.txt</span><br><span class="line">China</span><br><span class="line">America</span><br><span class="line">Janpan</span><br><span class="line">china</span><br></pre></td></tr></table></figure><p>上面这个\$NF 就表示每一行的最后一列，因为 NF 表示一行的总列数，在这个文件里表示有 5 列，然后在其前面加上 \$ 符号，就变成了 $5 ，表示第 5 列<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print $(NF - 1)&#125;&apos; fruit.txt</span><br><span class="line">1997</span><br><span class="line">1986</span><br><span class="line">1990</span><br><span class="line">2008</span><br></pre></td></tr></table></figure></p><p>上面 \$(NF-1) 表示倒数第 2 列， $(NF-2) 表示倒数第 3 列，依次类推。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yahoo   100 4500</span><br><span class="line">google  150 7500</span><br><span class="line">apple   180 8000</span><br><span class="line">twitter 120 5000</span><br></pre></td></tr></table></figure></p><p>我们用 fruit.txt 和 company.txt 两个文件来向你演示 awk 同时处理多个文件的时候有什么效果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print FILENAME &quot;\t&quot; $0&#125;&apos; fruit.txt company.txt</span><br><span class="line">fruit.txt       peach    100   Mar  1997   China</span><br><span class="line">fruit.txt       Lemon    150   Jan  1986   America</span><br><span class="line">fruit.txt       Pear     240   Mar  1990   Janpan</span><br><span class="line">fruit.txt       avocado  120   Feb  2008   china</span><br><span class="line">company.txt     yahoo   100 4500</span><br><span class="line">company.txt     google  150 7500</span><br><span class="line">company.txt     apple   180 8000</span><br><span class="line">company.txt     twitter 120 5000</span><br></pre></td></tr></table></figure></p><p>当你使用 awk 同时处理多个文件的时候，它会将多个文件合并处理，变量 FILENAME 就表示当前文本行所在的文件名称。</p><p>看到这里是不是感觉 awk 命令的使用方法真的是简单到爆炸，现在不要太高兴，请举起你的双手跟我一起摇摆。。。哦，不对！请拿起你的双手在电脑上试一试上面这些例子。</p><h4 id="BEGIN-关键字的使用"><a href="#BEGIN-关键字的使用" class="headerlink" title="BEGIN 关键字的使用"></a>BEGIN 关键字的使用</h4><p>在脚本代码段前面使用 BEGIN 关键字时，它会在开始读取一个文件之前，运行一次 BEGIN 关键字后面的脚本代码段， BEGIN 后面的脚本代码段只会执行一次，执行完之后 awk 程序就会退出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;BEGIN &#123;print &quot;Start read file&quot;&#125;&apos; /etc/passwd</span><br><span class="line">Start read file</span><br></pre></td></tr></table></figure></p><p> awk 脚本中可以用多个花括号来执行多个脚本代码，就像下面这样<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;BEGIN &#123;print &quot;Start read file&quot;&#125; &#123;print $0&#125;&apos; /etc/passwd</span><br><span class="line">Start read file</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="line">mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line">games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="line">ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">nobody:x:99:99:Nobody:/:/sbin/nologin</span><br></pre></td></tr></table></figure></p><h4 id="END-关键字使用方法"><a href="#END-关键字使用方法" class="headerlink" title="END 关键字使用方法"></a>END 关键字使用方法</h4><p>awk 的 END 指令和 BEGIN 恰好相反，在 awk 读取并且处理完文件的所有内容行之后，才会执行 END 后面的脚本代码段<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;END &#123;print &quot;End file&quot;&#125;&apos; /etc/passwd</span><br><span class="line">End file</span><br></pre></td></tr></table></figure></p><p>一定要多动手在电脑上敲一敲这些命令，对身体好。脑子是个好东西，要多用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;BEGIN &#123;print &quot;Start read file&quot;&#125; &#123;print $0&#125; END &#123;print &quot;End file&quot;&#125;&apos; /etc/passwd</span><br><span class="line">Start read file</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="line">mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line">games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="line">ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">nobody:x:99:99:Nobody:/:/sbin/nologin</span><br><span class="line">End file</span><br></pre></td></tr></table></figure></p><h4 id="在-awk-中使用变量"><a href="#在-awk-中使用变量" class="headerlink" title="在 awk 中使用变量"></a>在 awk 中使用变量</h4><p>可以在 awk 脚本中声明和使用变量<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;msg=&quot;hello world&quot;; print msg&#125;&apos; /etc/passwd</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>awk 声明的变量可以在任何多个花括号脚本中使用<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;BEGIN &#123;msg=&quot;hello world&quot;&#125; &#123;print msg&#125;&apos; /etc/passwd</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><h5 id="在-awk-中使用数学运算"><a href="#在-awk-中使用数学运算" class="headerlink" title="在 awk 中使用数学运算"></a>在 awk 中使用数学运算</h5><p>在 awk 中，像其他编程语言一样，它也支持一些基本的数学运算操作<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;a = 12; b = 24; print a + b&#125;&apos; company.txt</span><br><span class="line">36</span><br><span class="line">36</span><br><span class="line">36</span><br><span class="line">36</span><br></pre></td></tr></table></figure></p><p>上面这段脚本表示，先声明两个变量 a = 12 和 b = 24，然后用 print 打印出 a 加上 b 的结果。</p><p>看到上面的输出结果，你很可能又是一脸的懵逼，为什么会重复输出 4 次同样的计算结果。所以说小时不学好，长大做IT。 知识这东西真到了要用的时候，能亮瞎别人的双眼，好了，不废话。请记住 awk 是针对文件的每一行来执行一次单引号里面的脚本代码，每读取到一行就会执行一次，文件里面有多少行就会执行多少次，但 BEGIN 和 END 关键字后面的 脚本代码除外，如果被处理的文件中什么都没有，那 awk 就一次都不会执行。。。</p><h4 id="awk-还支持其他的数学运算符"><a href="#awk-还支持其他的数学运算符" class="headerlink" title="awk 还支持其他的数学运算符"></a>awk 还支持其他的数学运算符</h4><blockquote><p>“+”  加法运算符<br>“-“  减法运算符<br>“*”  乘法运算符<br>/ 除法运算符<br>% 取余运算符</p></blockquote><h4 id="在-awk-中使用条件判断"><a href="#在-awk-中使用条件判断" class="headerlink" title="在 awk 中使用条件判断"></a>在 awk 中使用条件判断</h4><p>比如有一个文件 company.txt 内容如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yahoo   100 4500</span><br><span class="line">google  150 7500</span><br><span class="line">apple   180 8000</span><br><span class="line">twitter 120 5000</span><br></pre></td></tr></table></figure></p><p>我们要判断文件的第 3 列数据，也就是平均工资小于 5500 的公司，然后将其打印输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;$3 &lt; 5500 &#123;print $0&#125;&apos; company.txt</span><br><span class="line">yahoo   100 4500</span><br><span class="line">twitter 120 5000</span><br></pre></td></tr></table></figure></p><p>上面的命令结果就是平均工资小于 5500 的公司名单，\$3 &lt; 5500 表示当第 3 列字段的内容小于 5500 的时候才会执行后面的 {print $0} 代码块<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;$1 == &quot;yahoo&quot; &#123;print $0&#125;&apos; company.txt</span><br><span class="line">yahoo   100 4500</span><br></pre></td></tr></table></figure></p><h4 id="awk-还有一些其他的条件操作符如下"><a href="#awk-还有一些其他的条件操作符如下" class="headerlink" title="awk 还有一些其他的条件操作符如下"></a>awk 还有一些其他的条件操作符如下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt; 小于</span><br><span class="line">&lt;= 小于或等于</span><br><span class="line">== 等于</span><br><span class="line">!= 不等于</span><br><span class="line">&gt; 大于</span><br><span class="line">&gt;= 大于或等于</span><br><span class="line">~ 匹配正则表达式</span><br><span class="line">!~ 不匹配正则表达式</span><br></pre></td></tr></table></figure><p>使用 if 指令判断来实现上面同样的效果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;if ($3 &lt; 5500) print $0&#125;&apos; company.txt</span><br><span class="line">yahoo   100 4500</span><br><span class="line">twitter 120 5000</span><br></pre></td></tr></table></figure></p><p>上面表示如果第 3 列字段小于 5500 的时候就会执行后面的 print $0，很像 C 语言和 PHP 的语法对不对。 想到这里有一句话不知当讲不当讲，那就是 PHP 是世界上最好的语言。</p><h4 id="在-awk-中使用正则表达式"><a href="#在-awk-中使用正则表达式" class="headerlink" title="在 awk 中使用正则表达式"></a>在 awk 中使用正则表达式</h4><p> 在 awk 中支持正则表达式的使用，如果你还对正则表达式不是很了解，请先停下来，上 google 去搜一下。</p><p>比如现在我们有这么一个文件 poetry.txt 里面都是我写的诗，不要问我为什么那么的有才华。内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This above all: to thine self be true</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br><span class="line">There’s a special providence in the fall of a sparrow</span><br><span class="line">No matter how dark long, may eventually in the day arrival</span><br></pre></td></tr></table></figure></p><p>使用正则表达式匹配字符串 “There” ，将包含这个字符串的行打印并输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/There/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br><span class="line">There’s a special providence in the fall of a sparrow</span><br></pre></td></tr></table></figure></p><p>使用正则表达式配一个包含字母 t 和字母 e ，并且 t 和 e 中间只能有任意单个字符的行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/t.e/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br><span class="line">There’s a special providence in the fall of a sparrow</span><br><span class="line">No matter how dark long, may eventually in the day arrival</span><br></pre></td></tr></table></figure></p><p>如果只想匹配单纯的字符串 “t.e”， 那正则表达式就是这样的 /t.e/ ，用反斜杠来转义 . 符号 因为 . 在正则表达式里面表示任意单个字符。</p><p>使用正则表达式来匹配所有以 “The” 字符串开头的行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/^The/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br><span class="line">There’s a special providence in the fall of a sparrow</span><br></pre></td></tr></table></figure></p><p>在正则表达式中 ^ 表示以某某字符或者字符串开头。</p><p>使用正则表达式来匹配所有以 “true” 字符串结尾的行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/true$/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">This above all: to thine self be true</span><br></pre></td></tr></table></figure></p><p>在正则表达式中 $ 表示以某某字符或者字符串结尾。</p><p>又一个正则表达式例子如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/m[a]t/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">No matter how dark long, may eventually in the day arrival</span><br></pre></td></tr></table></figure></p><p>上面这个正则表达式 /m[a]t/ 表示匹配包含字符 m ，然后接着后面还要包含中间方括号中表示的单个字符 a ，最后还要包含字符 t 的行，输出结果中只有单词 “matter” 符合这个正则表达式的匹配。因为正则表达式 [a] 方括号中表示匹配里面的任意单个字符。</p><p>继续上面的一个新例子如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/^Th[ie]/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">This above all: to thine self be true</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br><span class="line">There’s a special providence in the fall of a sparrow</span><br></pre></td></tr></table></figure></p><p>这个例子中的正则表达式 /^Th[ie]/表示匹配以字符串 “Thi” 或者 “The” 开头的行，正则表达式方括号中表示匹配其中的任意单个字符。</p><p> 再继续上面的新的用法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/s[a-z]/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">This above all: to thine self be true</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br><span class="line">There’s a special providence in the fall of a sparrow</span><br></pre></td></tr></table></figure></p><p>正则表达式 /s[a-z]/ 表示匹配包含字符 s 然后后面跟着任意 a 到 z 之间的单个字符的字符串，比如 “se”, “so”, “sp” 等等。</p><p> 正则表达式 [] 方括号中还有一些其他用法比如下面这些</p><p>[a-zA-Z]  表示匹配小写的 a 到 z 之间的单个字符，或者大写的 A 到 Z 之间的单个字符<br>[^a-z]    符号 <code>^</code> 在方括号里面表示取反，也就是非的意思，表示匹配任何非 a 到 z 之间的单个字符</p><p>正则表达式中的星号 * 和加号 + 的使用方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/go*d/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br></pre></td></tr></table></figure></p><p>上面这个表示匹配包含字符串 “god”，并且中间的字母 “o” 可以出现 0 次或者多次，比如单词 “good” 就符合这个要求。 正则表达式中的 + 和星号原理差不多，只是加号表示任意 1 个或者 1 个以上，也就是必须至少要出现一次。</p><p><strong>正则表达式问号 ? 的使用方法</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/ba?d/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br></pre></td></tr></table></figure></p><p>正则表达式中的问号 ? 表示它前面的字符只能出现 0 次 或者 1 次，也就是可以不出现，也可以出现，但如果有出现也最多只能出现 1 次。</p><p><strong>正则表达式中的 {} 花括号用法</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/go&#123;2&#125;d/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br></pre></td></tr></table></figure></p><p>花括号 {} 表示规定它前面的字符必须出现的次数，像上面这个 /go{2}d/ 就表示只匹配字符串 “good”，也就是中间的字母 “o” 必须要出现 2 次。</p><p><strong>正则表达式中的花括号还有一些其他的用法如下:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/go&#123;2,3&#125;d/    表示字母 &quot;o&quot; 只能可以出现 2 次或者 3 次</span><br><span class="line">/go&#123;2,10&#125;d/   表示字母 &quot;o&quot; 只能可以出现 2次，3次，4次，5次，6次 ... 一直到 10 次</span><br><span class="line">/go&#123;2,&#125;d/     表示字母 &quot;o&quot; 必须至少出现 2 次或着 2 次以上</span><br></pre></td></tr></table></figure></p><p><strong>正则表达式中的圆括号的用法</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/th(in)&#123;1&#125;king/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br></pre></td></tr></table></figure></p><p>正则表达式中的圆括号表示将多个字符当成一个完整的对象来看待。比如 /th(in){1}king/ 就表示其中字符串 “in” 必须出现 1 次。而如果不加圆括号就变成了 /thin{1}king/ 这个就表示其中字符 “n” 必须出现 1 次。</p><p>看到这里，如果你对 poetry.txt 件中写的诗比较熟悉，你就会发现。。。我去！这诗根本就不是我写的。所以论多读书是多么的重要。我有幸借用莎士比亚的诗来向你讲解如何在 awk 中使用正则表达式。</p><h4 id="使用-awk-的一些总结"><a href="#使用-awk-的一些总结" class="headerlink" title="使用 awk 的一些总结"></a>使用 awk 的一些总结</h4><p>因为 awk 算起来也是一种编程语言，它的功能远远不止我们上面讲的这些，awk 还有一些其他比较复杂的功能。但一般我们不建议将 awk 用的太过于复杂。通常面对一些比较复杂的场景我们还是要使用其他的一些工具，比如 shell 脚本，Lua 等等……</p><blockquote><p>原文来自：jarly<br><a href="https://my.oschina.net/jarly/blog/898144" target="_blank" rel="noopener">https://my.oschina.net/jarly/blog/898144</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;awk 是一个强大的文本分析工具。它不仅是 Linux 中，也是任何环境中现有的功能最强大的数据处理引擎之一。相对于 grep 的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3275724-417ad6ad01ebe66d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;small_Awk_command&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.yueyongblog.com/tags/Linux/"/>
    
      <category term="awk" scheme="https://www.yueyongblog.com/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令行：find的26个用法示例</title>
    <link href="https://www.yueyongblog.com/26-examples-of-find-command-on-linux.html"/>
    <id>https://www.yueyongblog.com/26-examples-of-find-command-on-linux.html</id>
    <published>2018-07-09T17:56:24.807Z</published>
    <updated>2018-07-11T09:32:42.824Z</updated>
    
    <content type="html"><![CDATA[<p>Linux系统中的 find 命令在查找文件时非常有用而且方便。它可以根据不同的条件来查找文件，例如权限、拥有者、修改日期/时间、文件大小等等。在这篇文章中，我们将学习如何使用 find 命令以及它所提供的选项来查找文件。</p><p><img src="https://upload-images.jianshu.io/upload_images/3275724-747df0725bdbd395.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="small_find_command.jpg"></p><a id="more"></a><p>在绝大多数Linux发行版中，你都可以直接使用 find 命令而无需进行任何安装操作。如果你想在linux系统的命令行中变得特别高效，那么 find 是你必须掌握的命令之一。</p><p>find 命令的基本语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find [path] [option] [expression]</span><br></pre></td></tr></table></figure></p><h4 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h4><h5 id="1-列出当前目录和子目录下的所有文件"><a href="#1-列出当前目录和子目录下的所有文件" class="headerlink" title="1.列出当前目录和子目录下的所有文件"></a>1.列出当前目录和子目录下的所有文件</h5><p>这个命令会列出当前目录以及子目录下的所有文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find</span><br><span class="line">.</span><br><span class="line">./abc.txt</span><br><span class="line">./subdir</span><br><span class="line">./subdir/how.php</span><br><span class="line">./cool.php</span><br></pre></td></tr></table></figure></p><p>该命令与以下命令效果相同<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find .</span><br><span class="line">$ find . -print</span><br></pre></td></tr></table></figure></p><h5 id="2-查找特殊的目录或路径"><a href="#2-查找特殊的目录或路径" class="headerlink" title="2. 查找特殊的目录或路径"></a>2. 查找特殊的目录或路径</h5><p>下面的命令会查找当前目录下 test 文件夹中的文件，默认列出所有文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test</span><br><span class="line">./test</span><br><span class="line">./test/abc.txt</span><br><span class="line">./test/subdir</span><br><span class="line">./test/subdir/how.php</span><br><span class="line">./test/cool.php</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>下面的命令用于查找指定名称的文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test -name &quot;abc.txt&quot;</span><br><span class="line">./test/abc.txt</span><br></pre></td></tr></table></figure></p><p>也可以使用通配符<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test -name &quot;*.php&quot;</span><br><span class="line">./test/subdir/how.php</span><br><span class="line">./test/cool.php</span><br></pre></td></tr></table></figure></p><p>请注意，所有的文件夹都会被递归地查找。所以，这是用于查找指定扩展名文件的一种非常强大的方式。</p><p>如果我们尝试搜索 / 文件夹，也就是根目录，就会搜索整个文件系统，包括挂载的设备以及网络存储设备。所以请小心使用。当然，你随时可以通过按 Ctrl + C 来终止命令。</p><p>注意：当指定文件夹的时候（例如示例中的”./test”文件夹），忽略末尾的斜杠是没有问题的。但是，如果文件夹是一个指向其它位置的链接（symlink）时，你必须在末尾写上斜杠才能使find命令正常工作（find ./test/）。</p><h5 id="忽略大小写"><a href="#忽略大小写" class="headerlink" title="忽略大小写"></a>忽略大小写</h5><p>在查找文件名时，忽略大小写往往非常有用。要忽略大小写，只需要使用 iname 选项，而不是 name 选项。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test -iname &quot;*.Php&quot;</span><br><span class="line">./test/subdir/how.php</span><br><span class="line">./test/cool.php</span><br></pre></td></tr></table></figure></p><p>总是用双引号或单引号来包围匹配模式（文件名参数），这非常有用。不这样做的话有时也能正常工作，有时也可能会产生奇怪的结果。</p><h5 id="3-限制目录查找的深度"><a href="#3-限制目录查找的深度" class="headerlink" title="3. 限制目录查找的深度"></a>3. 限制目录查找的深度</h5><p>find 命令默认会递归查找整个目录树，而这非常消耗时间和资源。好在目录查找的深度可以手动指定。例如我们只想查找一到两层以内的子目录，可以通过 maxdepth 选项来指定。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test -maxdepth 2 -name &quot;*.php&quot;</span><br><span class="line">./test/subdir/how.php</span><br><span class="line">./test/cool.php</span><br><span class="line"></span><br><span class="line">$ find ./test -maxdepth 1 -name *.php</span><br><span class="line">./test/cool.php</span><br></pre></td></tr></table></figure></p><p>第二个示例中指定了 maxdepth 为1，表明最多只查找一层内的子目录，也就是只查找当前文件夹。</p><p>当我们只想在当前目录下查找，而不是查找整个目录树的时候，这个选项会特别有用。</p><p>与 maxdepth 选项相似，还有一个选项叫做 mindepth ，正如名字所表示的那样，它会至少到达第 N 层子目录后才开始查找文件。</p><h5 id="4-反向查找"><a href="#4-反向查找" class="headerlink" title="4. 反向查找"></a>4. 反向查找</h5><p>除了查找满足条件的文件之外，我们还可以查找不满足条件的所有文件。当我们知道要在查找中排除哪些文件时，这个选项就能发挥作用了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test -not -name &quot;*.php&quot;</span><br><span class="line">./test</span><br><span class="line">./test/abc.txt</span><br><span class="line">./test/subdir</span><br></pre></td></tr></table></figure></p><p>在上面的示例中我们找到了所有扩展名不是 php 的文件和文件夹。我们也可以使用感叹号 ! 来代替 -not。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./test ! -name &quot;*.php&quot;</span><br></pre></td></tr></table></figure></p><h5 id="5-结合多个查找条件"><a href="#5-结合多个查找条件" class="headerlink" title="5. 结合多个查找条件"></a>5. 结合多个查找条件</h5><p>我们可以同时使用多个查找条件来指定文件名并排除某些文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test -name &apos;abc*&apos; ! -name &apos;*.php&apos;</span><br><span class="line">./test/abc.txt</span><br><span class="line">./test/abc</span><br></pre></td></tr></table></figure></p><p>上面的命令查找所有以 abc 开头并且不含 .php 扩展名的文件。这个示例展现了 find 命令自带的查找表达式是多么的强大。</p><h4 id="OR-操作符"><a href="#OR-操作符" class="headerlink" title="OR 操作符"></a>OR 操作符</h4><p>当我们使用多个查找条件时， find 命令会将它们通过 AND 操作符结合起来，也就是说，只有满足所有条件的文件才会被列出。不过，如果我们需要进行基于 OR 运算的查找时，可以加上 -o 开关。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find -name &apos;*.php&apos; -o -name &apos;*.txt&apos;</span><br><span class="line">./abc.txt</span><br><span class="line">./subdir/how.php</span><br><span class="line">./abc.php</span><br><span class="line">./cool.php</span><br></pre></td></tr></table></figure></p><p>上面的命令查找所有以 .php 结尾或者以 .txt 结尾的文件。</p><h5 id="6-只查找文件或目录"><a href="#6-只查找文件或目录" class="headerlink" title="6. 只查找文件或目录"></a>6. 只查找文件或目录</h5><p>有时我们只想通过某个名字查找对应的文件或对应的目录，我们可以很容易实现这个要求。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test -name abc*</span><br><span class="line">./test/abc.txt</span><br><span class="line">./test/abc</span><br></pre></td></tr></table></figure></p><p><strong>只查找文件</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test -type f -name &quot;abc*&quot;</span><br><span class="line">./test/abc.txt</span><br></pre></td></tr></table></figure></p><p><strong>只查找目录</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test -type d -name &quot;abc*&quot;</span><br><span class="line">./test/abc</span><br></pre></td></tr></table></figure></p><p>非常有用而且方便！</p><h5 id="7-同时在多个目录下查找"><a href="#7-同时在多个目录下查找" class="headerlink" title="7. 同时在多个目录下查找"></a>7. 同时在多个目录下查找</h5><p>如果你想要在两个不同的目录内进行查找，命令非常简单。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test ./dir2 -type f -name &quot;abc*&quot;</span><br><span class="line">./test/abc.txt</span><br><span class="line">./dir2/abcdefg.txt</span><br></pre></td></tr></table></figure></p><p>检查一下，它确实列出了来自给定的两个目录的文件。</p><h5 id="8-查找隐藏文件"><a href="#8-查找隐藏文件" class="headerlink" title="8. 查找隐藏文件"></a>8. 查找隐藏文件</h5><p>在Linux系统中，隐藏文件的名字以英文的句号开头，即 . 。所以要列出隐藏文件，只需加上简单的文件名过滤条件就行了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ~ -type f -name &quot;.*&quot;</span><br></pre></td></tr></table></figure></p><p>####二、基于文件权限和属性的查找</p><p>######9. 查找指定权限的文件</p><p>通过指定 perm 选项，我们可以查找具有特定权限的文件。下面的示例中查找了所有具有 0664 权限的文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -type f -perm 0664</span><br><span class="line">./abc.txt</span><br><span class="line">./subdir/how.php</span><br><span class="line">./abc.php</span><br><span class="line">./cool.php</span><br></pre></td></tr></table></figure></p><p>我们可以用这个命令来查找带有错误权限的文件，这些文件可能会产生安全问题。</p><p>可以结合 反向查找 来进行权限检查。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -type f ! -perm 0777</span><br><span class="line">./abc.txt</span><br><span class="line">./subdir/how.php</span><br><span class="line">./abc.php</span><br><span class="line">./cool.php</span><br></pre></td></tr></table></figure></p><h5 id="10-查找具有-SGID-SUID-属性的文件"><a href="#10-查找具有-SGID-SUID-属性的文件" class="headerlink" title="10. 查找具有 SGID/SUID 属性的文件"></a>10. 查找具有 SGID/SUID 属性的文件</h5><p>下面的命令查找所有具有 644 权限和 SGID 属性的文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find / -perm 2644</span><br></pre></td></tr></table></figure></p><p>我们同样可以使用 1664 来查找设置了 粘滞位 （sticky bit）的文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find / -perm 1644</span><br></pre></td></tr></table></figure></p><p>perm 选项除了接受数值型参数外，同样接受 chmod 命令中的模式串。在下面的查找中，我们用另一种语法来代替数字。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find / -maxdepth 2 -perm /u=s 2&gt;/dev/null</span><br><span class="line">/bin/mount</span><br><span class="line">/bin/su</span><br><span class="line">/bin/ping6</span><br><span class="line">/bin/fusermount</span><br><span class="line">/bin/ping</span><br><span class="line">/bin/umount</span><br><span class="line">/sbin/mount.ecryptfs_private</span><br></pre></td></tr></table></figure></p><p>注意：由于权限不足，某些目录会拒接访问。命令中的 2&gt;/dev/null 正是用于清除输出中的错误访问结果。</p><h5 id="11-查找只读文件"><a href="#11-查找只读文件" class="headerlink" title="11. 查找只读文件"></a>11. 查找只读文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find /etc -maxdepth 1 -perm /u=r</span><br><span class="line">/etc</span><br><span class="line">/etc/thunderbird</span><br><span class="line">/etc/brltty</span><br><span class="line">/etc/dkms</span><br><span class="line">/etc/phpmyadmin</span><br><span class="line">... output truncated ...</span><br></pre></td></tr></table></figure><h5 id="12-查找可执行文件"><a href="#12-查找可执行文件" class="headerlink" title="12. 查找可执行文件"></a>12. 查找可执行文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find /bin -maxdepth 2 -perm /a=x</span><br><span class="line">/bin</span><br><span class="line">/bin/preseed_command</span><br><span class="line">/bin/mount</span><br><span class="line">/bin/zfgrep</span><br><span class="line">/bin/tempfile</span><br><span class="line">... output truncated ...</span><br></pre></td></tr></table></figure><h4 id="三、基于文件拥有者和用户组的查找"><a href="#三、基于文件拥有者和用户组的查找" class="headerlink" title="三、基于文件拥有者和用户组的查找"></a>三、基于文件拥有者和用户组的查找</h4><h5 id="13-查找属于特定用户的文件"><a href="#13-查找属于特定用户的文件" class="headerlink" title="13. 查找属于特定用户的文件"></a>13. 查找属于特定用户的文件</h5><p>查找当前目录下，属于 bob 的文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -user bob</span><br><span class="line">.</span><br><span class="line">./abc.txt</span><br><span class="line">./abc</span><br><span class="line">./subdir</span><br><span class="line">./subdir/how.php</span><br><span class="line">./abc.php</span><br></pre></td></tr></table></figure></p><p>在指定所属用户的同时，我们同样可以指定文件名。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -user bob -name &apos;*.php&apos;</span><br></pre></td></tr></table></figure></p><p>很容易看出，我们可以通过增加过滤条件来缩小查找文件的范围。</p><h5 id="14-查找属于特定用户组的文件"><a href="#14-查找属于特定用户组的文件" class="headerlink" title="14. 查找属于特定用户组的文件"></a>14. 查找属于特定用户组的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find /var/www -group developer</span><br></pre></td></tr></table></figure><h4 id="四、基于日期和时间的查找"><a href="#四、基于日期和时间的查找" class="headerlink" title="四、基于日期和时间的查找"></a>四、基于日期和时间的查找</h4><p>除了上面介绍的查找条件外，另外一个非常棒的查找条件就是文件的修改和访问时间（日期）。当我们想要找出哪些文件在某段时间内被修改的时候，这个查找条件将会非常方便。我们来看几个例子。</p><h5 id="15-查找过去的第-N-天被修改过的文件"><a href="#15-查找过去的第-N-天被修改过的文件" class="headerlink" title="15. 查找过去的第 N 天被修改过的文件"></a>15. 查找过去的第 N 天被修改过的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find / -mtime 50</span><br></pre></td></tr></table></figure><h5 id="16-查找过去的-N-天内被访问过的文件"><a href="#16-查找过去的-N-天内被访问过的文件" class="headerlink" title="16. 查找过去的 N 天内被访问过的文件"></a>16. 查找过去的 N 天内被访问过的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find / -atime -50</span><br></pre></td></tr></table></figure><h5 id="17-查找某段时间范围内被修改过内容的文件"><a href="#17-查找某段时间范围内被修改过内容的文件" class="headerlink" title="17. 查找某段时间范围内被修改过内容的文件"></a>17. 查找某段时间范围内被修改过内容的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find / -mtime +50 -mtime -100</span><br></pre></td></tr></table></figure><h5 id="18-查找过去的-N-分钟内状态发生改变的文件"><a href="#18-查找过去的-N-分钟内状态发生改变的文件" class="headerlink" title="18. 查找过去的 N 分钟内状态发生改变的文件"></a>18. 查找过去的 N 分钟内状态发生改变的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find /home/bob -cmin -60</span><br></pre></td></tr></table></figure><h5 id="19-查找过去的-1-小时内被修改过内容的文件"><a href="#19-查找过去的-1-小时内被修改过内容的文件" class="headerlink" title="19. 查找过去的 1 小时内被修改过内容的文件"></a>19. 查找过去的 1 小时内被修改过内容的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find / -mmin -60</span><br></pre></td></tr></table></figure><h5 id="20-查找过去的-1-小时内被访问过的文件"><a href="#20-查找过去的-1-小时内被访问过的文件" class="headerlink" title="20. 查找过去的 1 小时内被访问过的文件"></a>20. 查找过去的 1 小时内被访问过的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find / -amin -60</span><br></pre></td></tr></table></figure><h4 id="五、基于文件大小的查找"><a href="#五、基于文件大小的查找" class="headerlink" title="五、基于文件大小的查找"></a>五、基于文件大小的查找</h4><h5 id="21-查找指定大小的文件"><a href="#21-查找指定大小的文件" class="headerlink" title="21. 查找指定大小的文件"></a>21. 查找指定大小的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find / -size 50M</span><br></pre></td></tr></table></figure><h5 id="22-查找大小在一定范围内的文件"><a href="#22-查找大小在一定范围内的文件" class="headerlink" title="22. 查找大小在一定范围内的文件"></a>22. 查找大小在一定范围内的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find / -size +50M -size -100M</span><br></pre></td></tr></table></figure><h5 id="23-查找最大和最小的文件"><a href="#23-查找最大和最小的文件" class="headerlink" title="23. 查找最大和最小的文件"></a>23. 查找最大和最小的文件</h5><p>我们可以将 find 命令与 ls 和 sort命令结合，从而找出最大或最小的文件。</p><p>下面的命令使用了 sort 命令的 -r 选项，也就是从大到小降序排列。经过 head 命令的过滤之后，会显示当前目录和子目录下最大的5个文件。命令的执行过程需要一段时间，查找的速度取决于文件的总数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -type f -exec ls -s &#123;&#125; \; | sort -n -r | head 5</span><br></pre></td></tr></table></figure></p><p>同样，我们可以去掉 sort 命令的 -r 选项来进行升序排列，从而显示出最小的5个文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -type f -exec ls -s &#123;&#125; \; | sort -n | head 5</span><br></pre></td></tr></table></figure></p><h5 id="24-查找空文件和空目录"><a href="#24-查找空文件和空目录" class="headerlink" title="24. 查找空文件和空目录"></a>24. 查找空文件和空目录</h5><p>查找空文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find /tmp -type f -empty</span><br></pre></td></tr></table></figure></p><p>查找空目录：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ~/ -type d -empty</span><br></pre></td></tr></table></figure></p><p>非常简单！</p><h4 id="六、高级操作"><a href="#六、高级操作" class="headerlink" title="六、高级操作"></a>六、高级操作</h4><p>find 命令不仅可以通过特定条件来查找文件，还可以对查找到的文件使用任意linux命令进行操作。下面给出两个例子。</p><h5 id="25-使用-ls-命令列出文件信息"><a href="#25-使用-ls-命令列出文件信息" class="headerlink" title="25. 使用 ls 命令列出文件信息"></a>25. 使用 ls 命令列出文件信息</h5><p>我们使用 find 命令找到文件后，只能看到文件路径。如果想进一步查看文件信息，可以结合 ls 命令来实现。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -exec ls -ld &#123;&#125; \;</span><br><span class="line">drwxrwxr-x 4 enlightened enlightened 4096 Aug 11 19:01 .</span><br><span class="line">-rw-rw-r-- 1 enlightened enlightened 0 Aug 11 16:25 ./abc.txt</span><br><span class="line">drwxrwxr-x 2 enlightened enlightened 4096 Aug 11 16:48 ./abc</span><br><span class="line">drwxrwxr-x 2 enlightened enlightened 4096 Aug 11 16:26 ./subdir</span><br><span class="line">-rw-rw-r-- 1 enlightened enlightened 0 Aug 11 16:26 ./subdir/how.php</span><br><span class="line">-rw-rw-r-- 1 enlightened enlightened 29 Aug 11 19:13 ./abc.php</span><br><span class="line">-rw-rw-r-- 1 enlightened enlightened 0 Aug 11 16:25 ./cool.php</span><br></pre></td></tr></table></figure></p><h5 id="26-删除找到的文件"><a href="#26-删除找到的文件" class="headerlink" title="26. 删除找到的文件"></a>26. 删除找到的文件</h5><p>下面的命令会删除 tmp 目录下扩展名为 .txt 的文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find /tmp -type f -name &quot;*.txt&quot; -exec rm -f &#123;&#125; \;</span><br></pre></td></tr></table></figure></p><p>我们同样可以删除目录，只要把 -type 后面的 f 改为 d ，并且在 rm 命令后面加上 -r 即可。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find /tmp -type d -name &quot;dirToRemove&quot; -exec rm -r -f &#123;&#125; \;</span><br></pre></td></tr></table></figure></p><p><strong>原文来自：<a href="http://www.codebelief.com/article/2017/02/26-examples-of-find-command-on-linux/" target="_blank" rel="noopener">http://www.codebelief.com/article/2017/02/26-examples-of-find-command-on-linux/</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux系统中的 find 命令在查找文件时非常有用而且方便。它可以根据不同的条件来查找文件，例如权限、拥有者、修改日期/时间、文件大小等等。在这篇文章中，我们将学习如何使用 find 命令以及它所提供的选项来查找文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3275724-747df0725bdbd395.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;small_find_command.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.yueyongblog.com/tags/Linux/"/>
    
      <category term="find" scheme="https://www.yueyongblog.com/tags/find/"/>
    
  </entry>
  
  <entry>
    <title>Markdown的常用语法总结</title>
    <link href="https://www.yueyongblog.com/Markdown-use.html"/>
    <id>https://www.yueyongblog.com/Markdown-use.html</id>
    <published>2018-05-29T16:23:44.070Z</published>
    <updated>2018-06-29T07:58:03.453Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3275724-090129e5e0ae2657.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><h4 id="Markdown是什么？"><a href="#Markdown是什么？" class="headerlink" title="Markdown是什么？"></a>Markdown是什么？</h4><p>Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 其中最重要的设计是可读性，也就是说这个语言应该要能直接在字面上的被阅读，而不用被一些格式化指令标记(像是 RTF 与 HTML)。</p><p>下面总结一下Markdown常用的基础语法，让你快速掌握，并运用。</p><h4 id="Markdown的优点："><a href="#Markdown的优点：" class="headerlink" title="Markdown的优点："></a>Markdown的优点：</h4><p>1.纯文本，所以兼容性极强，可以用所有文本编辑器打开。<br>2.让你专注于文字而不是排版。<br>3.格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。<br>4.Markdown 的标记语法有极好的可读性。</p><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题             //表示是一级标题或使用&lt;h1&gt;</span><br><span class="line">## 二级标题            //表示是二级标题或使用&lt;h2&gt;</span><br><span class="line">### 三级标题           //表示是三级标题或使用&lt;h3&gt;</span><br><span class="line">#### 四级标题          //表示是四级标题或使用&lt;h4&gt;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>在所需的文字前面加上<code>#</code>号和空格符，注意<code>#</code>号后面的空格，也可以使用HTML代码表示标题，这里不详解。</p><h4 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h4><p>用一个<code>*</code>或者<code>_</code>包含起来表示斜体；<br>显示效果如下：<br><em>强调</em>  或者  _强调_</p><p>用两个<code>**</code> 和<code>__</code>包含起来表示粗体；<br>显示效果如下：<br><strong>加重强调</strong> 或者 <strong>加重强调</strong></p><p>用三个<code>***</code> 或者<code>___</code>表示粗斜体；<br>显示效果如下：<br><strong><em>强调</em></strong>  <strong>_强调_</strong></p><p>使用两个<code>~~</code>表示删除；<br><del>删除</del></p><h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><p>在Markdown中，插入链接直接使用<code>[显示文本](链接地址)</code>这样的语法即可，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[YueYong&apos;s Blog](http://yueyongblog.com)</span><br></pre></td></tr></table></figure></p><p>显示效果如下：<br><a href="http://yueyongblog.com" target="_blank" rel="noopener">YueYong’s Blog</a></p><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p>插入图片使用<code>![](图片链接地址)</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![这里描述信息](http://upload-images.jianshu.io/upload_images/3275724-8fea54b4fef2cec2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br></pre></td></tr></table></figure></p><p>显示效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/3275724-8fea54b4fef2cec2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表格式也很常用，只需要在文字前面加上<code>-</code> 就可以了，例如：</p><p><strong>无序列表：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 文本1</span><br><span class="line">- 文本2</span><br><span class="line">- 文本3</span><br></pre></td></tr></table></figure></p><p>显示效果如下：</p><ul><li>文本1</li><li>文本2</li><li>文本3</li></ul><p><strong>有序列表：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 文本1</span><br><span class="line">2. 文本2</span><br><span class="line">3. 文本3</span><br></pre></td></tr></table></figure></p><p>显示效果如下：<br>1.文本1<br>2.文本2<br>3.文本3</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>在写作的过程中会引用别人的文字，或者在文章末尾用到，需要在文章前面加上<code>&gt;</code>和空格字符就好了。</p><p>显示效果如下：</p><blockquote><p>人生如梦，岁月无情，豁然回首，才发现人活着是一种心情，穷也好，富也好；得也好，失也好，一切都是过眼云烟。想想不管昨天、今天、明天。能豁然开朗就是美好的一天。不管亲情，友情，爱情。能永远珍惜就是好心情。记得有位朋友说过这样的话：“曾经拥有的不要忘记，已经得到的更加珍惜，属于自己的不要放弃，已经失去的留作回忆，想要得到，一定要努力。</p></blockquote><h4 id="代码块的引用"><a href="#代码块的引用" class="headerlink" title="代码块的引用"></a>代码块的引用</h4><p>当编写代码时,需要时代码的引用，使用三个<code>```</code>,table上面那个按键，<br>还可以单独使用一个<code>`</code> 包含需要的文字或单词、代码等；<br>显示效果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello world!</span><br><span class="line">Life is short, I learn python</span><br><span class="line">This is YueYong&apos;s blog</span><br></pre></td></tr></table></figure><p><code>world</code></p><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>在编写一段文字的时候，需要另起一段，使用Eenter按键直接换行，或者使用<code>br</code>标签</p><h4 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h4><p>可以在单独一行里输入3个或以上的短横线、星号或者下划线均可实现；<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * *</span><br><span class="line">***</span><br><span class="line">*****</span><br><span class="line">- - -</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure></p><p>显示效果如下：</p><hr><hr><h4 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表:"></a>任务列表:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-  [x] 任务1，已完成;</span><br><span class="line">-  [x] 任务2，已完成;</span><br><span class="line">-  [ ] 任务3，未完成;</span><br></pre></td></tr></table></figure><p>显示效果如下：</p><ul><li style="list-style: none"><input type="checkbox" checked> 任务1，已完成;</li><li style="list-style: none"><input type="checkbox" checked> 任务2，已完成;</li><li style="list-style: none"><input type="checkbox"> 任务3，未完成;</li></ul><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>:— 表示居左，即默认格式， :—: 表示居中，—: 表示居右；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 姓名| 性别 | 年龄 |</span><br><span class="line">|:-----|:-----:|-----:|</span><br><span class="line">| 张三 | 男   | 18 |</span><br><span class="line">| 李四 | 女   | 17 |</span><br></pre></td></tr></table></figure><p>显示效果如下：</p><table><thead><tr><th style="text-align:left">姓名</th><th style="text-align:center">性别</th><th style="text-align:right">年龄</th></tr></thead><tbody><tr><td style="text-align:left">张三</td><td style="text-align:center">男</td><td style="text-align:right">18</td></tr><tr><td style="text-align:left">李四</td><td style="text-align:center">女</td><td style="text-align:right">17</td></tr></tbody></table><p><br></p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="http://www.jianshu.com/p/q81RER#" target="_blank" rel="noopener">献给写作者的 Markdown 新手指南</a><br><a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">Markdown 语法说明 (简体中文版)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3275724-090129e5e0ae2657.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Markdown" scheme="https://www.yueyongblog.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Hello World —— My Blog！</title>
    <link href="https://www.yueyongblog.com/hello-blog.html"/>
    <id>https://www.yueyongblog.com/hello-blog.html</id>
    <published>2018-05-29T15:49:56.306Z</published>
    <updated>2018-06-29T12:56:41.328Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="security">  <div class="input-container">  <input type="password" class="form-control" id="pass" placeholder="请输入文章密码" />    <label for="pass">请输入文章密码</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      欢迎您来我的小窝，终于抽空把博客搭建好了……
    
    </summary>
    
    
      <category term="随笔" scheme="https://www.yueyongblog.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
