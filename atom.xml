<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yue Yong&#39;s Blog</title>
  
  <subtitle>众里寻他千百度，蓦然回首，那人却在灯火阑珊处</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.yueyongblog.com/"/>
  <updated>2018-07-15T08:14:36.023Z</updated>
  <id>https://www.yueyongblog.com/</id>
  
  <author>
    <name>Yong YUE</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何在Linux中使用awk工具详解</title>
    <link href="https://www.yueyongblog.com/awk-command.html"/>
    <id>https://www.yueyongblog.com/awk-command.html</id>
    <published>2018-07-15T08:13:15.851Z</published>
    <updated>2018-07-15T08:14:36.023Z</updated>
    
    <content type="html"><![CDATA[<p>awk 是一个强大的文本分析工具。它不仅是 Linux 中，也是任何环境中现有的功能最强大的数据处理引擎之一。相对于 grep 的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。</p><p><img src="https://upload-images.jianshu.io/upload_images/3275724-417ad6ad01ebe66d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="small_Awk_command"></p><a id="more"></a><p>当你第一次拿起双手在电脑上使用 awk 命令处理一个或者多个文件的时候，它会依次读取文件的每一行内容, 然后对其进行处理，awk 命令默认从 stdio 标准输入获取文件内容, awk 使用一对单引号来表示 一些可执行的脚本代码，在可执行脚本代码里面，使用一对花括号来表示一段可执行代码块，可以同时存在多个代码块。</p><p> awk 的每个花括号内同时又可以有多个指令，每一个指令用分号分隔，awk 其实就是一个脚本编程语言。说了这么多，你肯定还是一脸的懵逼。你猜对了，上面这些都是废话。先别急，客官请往下看……</p><h4 id="awk-命令的基本格式"><a href="#awk-命令的基本格式" class="headerlink" title="awk 命令的基本格式"></a>awk 命令的基本格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk [options] &apos;program&apos; file</span><br></pre></td></tr></table></figure><p>options 这个表示一些可选的参数选项<br>program 这个表示 awk 的可执行脚本代码，这个是必须要有的。<br>file 这个表示 awk 需要处理的文件，注意是纯文本文件，不是你的 mp3，也不是 mp4 啥的。</p><h4 id="先来一个-awk-的使用例子热热身"><a href="#先来一个-awk-的使用例子热热身" class="headerlink" title="先来一个 awk 的使用例子热热身"></a>先来一个 awk 的使用例子热热身</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print $0&#125;&apos; /etc/passwd</span><br></pre></td></tr></table></figure><p>awk 命令的可执行脚本代码使用单引号括起来，紧接着里面是一对花括号，记住是 “花括号” 不是 “花姑娘”，然后花括号里面就是一些可执行的脚本代码段;<br>当 awk 每读取一行之后，它会依次执行双引号里面的每个脚本代码段，在上面这个例子中， $0 表示当前行。当你执行了上面的命令之后，它会依次将 /etc/passwd 文件的每一行内容打印输出，你一定在想：这有个毛用，用 cat 命令也能搞定。没错！上面这个命令没个毛用，请往下看。</p><h4 id="awk-自定义分隔符"><a href="#awk-自定义分隔符" class="headerlink" title="awk 自定义分隔符"></a>awk 自定义分隔符</h4><p>awk 默认的分割符为空格和制表符，我们可以使用 -F 参数来指定分隔符<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk -F &apos;:&apos; &apos;&#123;print $1&#125;&apos; /etc/passwd</span><br><span class="line">root</span><br><span class="line">bin</span><br><span class="line">daemon</span><br><span class="line">adm</span><br><span class="line">lp</span><br><span class="line">sync</span><br><span class="line">shutdown</span><br><span class="line">halt</span><br><span class="line">mail</span><br><span class="line">operator</span><br><span class="line">games</span><br><span class="line">ftp</span><br><span class="line">nobody</span><br></pre></td></tr></table></figure></p><p>上面的命令将 /etc/passwd 文件中的每一行用冒号 : 分割成多个字段，然后用 print 将第 1 列字段的内容打印输出</p><h4 id="如何在-awk-中同时指定多个分隔符"><a href="#如何在-awk-中同时指定多个分隔符" class="headerlink" title="如何在 awk 中同时指定多个分隔符"></a>如何在 awk 中同时指定多个分隔符</h4><p>比如现在有这样一个文件 some.log 文件内容如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Grape(100g)1980</span><br><span class="line">raisins(500g)1990</span><br><span class="line">plum(240g)1997</span><br><span class="line">apricot(180g)2005</span><br><span class="line">nectarine(200g)2008</span><br></pre></td></tr></table></figure></p><p>现在我们想将上面的 some.log 文件中按照 “水果名称(重量)年份” 来进行分割<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk -F &apos;[()]&apos; &apos;&#123;print $1, $2, $3&#125;&apos; some.log</span><br><span class="line">Grape 100g 1980</span><br><span class="line">raisins 500g 1990</span><br><span class="line">plum 240g 1997</span><br><span class="line">apricot 180g 2005</span><br><span class="line">nectarine 200g 2008</span><br></pre></td></tr></table></figure></p><p>在 -F 参数中使用一对方括号来指定多个分隔符，awk 处理 some.log 文件时就会使用 “(” 和 “)” 来对文件的每一行进行分割。</p><h4 id="awk-内置变量的使用"><a href="#awk-内置变量的使用" class="headerlink" title="awk 内置变量的使用"></a>awk 内置变量的使用</h4><ul><li>$0 这个表示文本处理时的当前行</li><li>$1 表示文本行被分隔后的第 1 个字段列</li><li>$2 表示文本行被分割后的第 2 个字段列</li><li>$3 表示文本行被分割后的第 3 个字段列</li><li>$n 表示文本行被分割后的第 n 个字段列</li><li>NR 表示文件中的行号，表示当前是第几行</li><li>NF 表示文件中的当前行列的个数，类似于 mysql 数据表里面每一条记录有多少个字段。</li><li>FS 表示 awk 的输入分隔符，默认分隔符为空格和制表符，你可以对其进行自定义设置</li><li>OFS 表示 awk 的输出分隔符，默认为空格，你也可以对其进行自定义设置</li><li>FILENAME 表示当前文件的文件名称，如果同时处理多个文件，它也表示当前文件名称</li></ul><p>比如我们有这么一个文本文件 fruit.txt 内容如下，我将用它来向你演示如何使用 awk 命令工具，顺便活跃一下此时尴尬的气氛。。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">peach    100   Mar  1997   China</span><br><span class="line">Lemon    150   Jan  1986   America</span><br><span class="line">Pear     240   Mar  1990   Janpan</span><br><span class="line">avocado  120   Feb  2008   china</span><br></pre></td></tr></table></figure></p><p>我们来瞧一瞧下面这些简单到爆炸的例子，这个表示打印输出文件的每一整行的内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print $0&#125;&apos; fruit.txt</span><br><span class="line">peach    100   Mar  1997   China</span><br><span class="line">Lemon    150   Jan  1986   America</span><br><span class="line">Pear     240   Mar  1990   Janpan</span><br><span class="line">avocado  120   Feb  2008   china</span><br></pre></td></tr></table></figure></p><p>下面这个表示打印输出文件的每一行的第 1 列内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print $1&#125;&apos; fruit.txt</span><br><span class="line">peach</span><br><span class="line">Lemon</span><br><span class="line">Pear</span><br><span class="line">avocado</span><br></pre></td></tr></table></figure></p><p>下面面这个表示打印输出文件的每一行的第 1 列、第 2 列和第 3 列内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print $1, $2, $3&#125;&apos; fruit.txt</span><br><span class="line">peach 100 Mar</span><br><span class="line">Lemon 150 Jan</span><br><span class="line">Pear 240 Mar</span><br><span class="line">avocado 120 Feb</span><br></pre></td></tr></table></figure></p><p>其中加入的逗号表示插入输出分隔符，也就是默认的空格</p><p>文件的每一行的每一列的内容除了可以用 print 命令打印输出以外，还可以对其进行赋值<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;$2 = &quot;***&quot;; print $0&#125;&apos; fruit.txt</span><br><span class="line">peach *** Mar 1997 China</span><br><span class="line">Lemon *** Jan 1986 America</span><br><span class="line">Pear *** Mar 1990 Janpan</span><br><span class="line">avocado *** Feb 2008 china</span><br></pre></td></tr></table></figure></p><p>上面的例子就是表示通过对 $2 变量进行重新赋值，来隐藏每一行的第 2 列内容，并且用星号 * 来代替其输出</p><p>在参数列表中加入一些字符串或者转义字符之类的东东<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print $1 &quot;\t&quot; $2 &quot;\t&quot; $3&#125;&apos; fruit.txt</span><br><span class="line">peach      100      Mar</span><br><span class="line">Lemon    150      Jan</span><br><span class="line">Pear        240     Mar</span><br><span class="line">avocado 120      Feb</span><br></pre></td></tr></table></figure></p><p>像上面这样，你可以在 print的参数列表中加入一些字符串或者转义字符之类的东东，让输出的内容格式更漂亮，但一定要记住要使用双引号。</p><h4 id="awk-内置-NR-变量表示每一行的行号"><a href="#awk-内置-NR-变量表示每一行的行号" class="headerlink" title="awk 内置 NR 变量表示每一行的行号"></a>awk 内置 NR 变量表示每一行的行号</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print NR &quot;\t&quot; $0&#125;&apos; fruit.txt</span><br><span class="line">1   peach    100   Mar  1997   China</span><br><span class="line">2   Lemon    150   Jan  1986   America</span><br><span class="line">3   Pear     240   Mar  1990   Janpan</span><br><span class="line">4   avocado  120   Feb  2008   china</span><br></pre></td></tr></table></figure><h4 id="awk-内置-NF-变量表示每一行的列数"><a href="#awk-内置-NF-变量表示每一行的列数" class="headerlink" title="awk 内置 NF 变量表示每一行的列数"></a>awk 内置 NF 变量表示每一行的列数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print NF &quot;\t&quot; $0&#125;&apos; fruit.txt</span><br><span class="line">5   peach    100   Mar  1997   China</span><br><span class="line">5   Lemon    150   Jan  1986   America</span><br><span class="line">5   Pear     240   Mar  1990   Janpan</span><br><span class="line">5   avocado  120   Feb  2008   china</span><br></pre></td></tr></table></figure><h4 id="awk-中-NF-变量的使用"><a href="#awk-中-NF-变量的使用" class="headerlink" title="awk 中 $NF 变量的使用"></a>awk 中 $NF 变量的使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print $NF&#125;&apos; fruit.txt</span><br><span class="line">China</span><br><span class="line">America</span><br><span class="line">Janpan</span><br><span class="line">china</span><br></pre></td></tr></table></figure><p>上面这个\$NF 就表示每一行的最后一列，因为 NF 表示一行的总列数，在这个文件里表示有 5 列，然后在其前面加上 \$ 符号，就变成了 $5 ，表示第 5 列<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print $(NF - 1)&#125;&apos; fruit.txt</span><br><span class="line">1997</span><br><span class="line">1986</span><br><span class="line">1990</span><br><span class="line">2008</span><br></pre></td></tr></table></figure></p><p>上面 \$(NF-1) 表示倒数第 2 列， $(NF-2) 表示倒数第 3 列，依次类推。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yahoo   100 4500</span><br><span class="line">google  150 7500</span><br><span class="line">apple   180 8000</span><br><span class="line">twitter 120 5000</span><br></pre></td></tr></table></figure></p><p>我们用 fruit.txt 和 company.txt 两个文件来向你演示 awk 同时处理多个文件的时候有什么效果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;print FILENAME &quot;\t&quot; $0&#125;&apos; fruit.txt company.txt</span><br><span class="line">fruit.txt       peach    100   Mar  1997   China</span><br><span class="line">fruit.txt       Lemon    150   Jan  1986   America</span><br><span class="line">fruit.txt       Pear     240   Mar  1990   Janpan</span><br><span class="line">fruit.txt       avocado  120   Feb  2008   china</span><br><span class="line">company.txt     yahoo   100 4500</span><br><span class="line">company.txt     google  150 7500</span><br><span class="line">company.txt     apple   180 8000</span><br><span class="line">company.txt     twitter 120 5000</span><br></pre></td></tr></table></figure></p><p>当你使用 awk 同时处理多个文件的时候，它会将多个文件合并处理，变量 FILENAME 就表示当前文本行所在的文件名称。</p><p>看到这里是不是感觉 awk 命令的使用方法真的是简单到爆炸，现在不要太高兴，请举起你的双手跟我一起摇摆。。。哦，不对！请拿起你的双手在电脑上试一试上面这些例子。</p><h4 id="BEGIN-关键字的使用"><a href="#BEGIN-关键字的使用" class="headerlink" title="BEGIN 关键字的使用"></a>BEGIN 关键字的使用</h4><p>在脚本代码段前面使用 BEGIN 关键字时，它会在开始读取一个文件之前，运行一次 BEGIN 关键字后面的脚本代码段， BEGIN 后面的脚本代码段只会执行一次，执行完之后 awk 程序就会退出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;BEGIN &#123;print &quot;Start read file&quot;&#125;&apos; /etc/passwd</span><br><span class="line">Start read file</span><br></pre></td></tr></table></figure></p><p> awk 脚本中可以用多个花括号来执行多个脚本代码，就像下面这样<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;BEGIN &#123;print &quot;Start read file&quot;&#125; &#123;print $0&#125;&apos; /etc/passwd</span><br><span class="line">Start read file</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="line">mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line">games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="line">ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">nobody:x:99:99:Nobody:/:/sbin/nologin</span><br></pre></td></tr></table></figure></p><h4 id="END-关键字使用方法"><a href="#END-关键字使用方法" class="headerlink" title="END 关键字使用方法"></a>END 关键字使用方法</h4><p>awk 的 END 指令和 BEGIN 恰好相反，在 awk 读取并且处理完文件的所有内容行之后，才会执行 END 后面的脚本代码段<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;END &#123;print &quot;End file&quot;&#125;&apos; /etc/passwd</span><br><span class="line">End file</span><br></pre></td></tr></table></figure></p><p>一定要多动手在电脑上敲一敲这些命令，对身体好。脑子是个好东西，要多用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;BEGIN &#123;print &quot;Start read file&quot;&#125; &#123;print $0&#125; END &#123;print &quot;End file&quot;&#125;&apos; /etc/passwd</span><br><span class="line">Start read file</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="line">mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line">games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="line">ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">nobody:x:99:99:Nobody:/:/sbin/nologin</span><br><span class="line">End file</span><br></pre></td></tr></table></figure></p><h4 id="在-awk-中使用变量"><a href="#在-awk-中使用变量" class="headerlink" title="在 awk 中使用变量"></a>在 awk 中使用变量</h4><p>可以在 awk 脚本中声明和使用变量<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;msg=&quot;hello world&quot;; print msg&#125;&apos; /etc/passwd</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>awk 声明的变量可以在任何多个花括号脚本中使用<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;BEGIN &#123;msg=&quot;hello world&quot;&#125; &#123;print msg&#125;&apos; /etc/passwd</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><h5 id="在-awk-中使用数学运算"><a href="#在-awk-中使用数学运算" class="headerlink" title="在 awk 中使用数学运算"></a>在 awk 中使用数学运算</h5><p>在 awk 中，像其他编程语言一样，它也支持一些基本的数学运算操作<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;a = 12; b = 24; print a + b&#125;&apos; company.txt</span><br><span class="line">36</span><br><span class="line">36</span><br><span class="line">36</span><br><span class="line">36</span><br></pre></td></tr></table></figure></p><p>上面这段脚本表示，先声明两个变量 a = 12 和 b = 24，然后用 print 打印出 a 加上 b 的结果。</p><p>看到上面的输出结果，你很可能又是一脸的懵逼，为什么会重复输出 4 次同样的计算结果。所以说小时不学好，长大做IT。 知识这东西真到了要用的时候，能亮瞎别人的双眼，好了，不废话。请记住 awk 是针对文件的每一行来执行一次单引号里面的脚本代码，每读取到一行就会执行一次，文件里面有多少行就会执行多少次，但 BEGIN 和 END 关键字后面的 脚本代码除外，如果被处理的文件中什么都没有，那 awk 就一次都不会执行。。。</p><h4 id="awk-还支持其他的数学运算符"><a href="#awk-还支持其他的数学运算符" class="headerlink" title="awk 还支持其他的数学运算符"></a>awk 还支持其他的数学运算符</h4><blockquote><p>“+”  加法运算符<br>“-“  减法运算符<br>“*”  乘法运算符<br>/ 除法运算符<br>% 取余运算符</p></blockquote><h4 id="在-awk-中使用条件判断"><a href="#在-awk-中使用条件判断" class="headerlink" title="在 awk 中使用条件判断"></a>在 awk 中使用条件判断</h4><p>比如有一个文件 company.txt 内容如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yahoo   100 4500</span><br><span class="line">google  150 7500</span><br><span class="line">apple   180 8000</span><br><span class="line">twitter 120 5000</span><br></pre></td></tr></table></figure></p><p>我们要判断文件的第 3 列数据，也就是平均工资小于 5500 的公司，然后将其打印输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;$3 &lt; 5500 &#123;print $0&#125;&apos; company.txt</span><br><span class="line">yahoo   100 4500</span><br><span class="line">twitter 120 5000</span><br></pre></td></tr></table></figure></p><p>上面的命令结果就是平均工资小于 5500 的公司名单，\$3 &lt; 5500 表示当第 3 列字段的内容小于 5500 的时候才会执行后面的 {print $0} 代码块<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;$1 == &quot;yahoo&quot; &#123;print $0&#125;&apos; company.txt</span><br><span class="line">yahoo   100 4500</span><br></pre></td></tr></table></figure></p><h4 id="awk-还有一些其他的条件操作符如下"><a href="#awk-还有一些其他的条件操作符如下" class="headerlink" title="awk 还有一些其他的条件操作符如下"></a>awk 还有一些其他的条件操作符如下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt; 小于</span><br><span class="line">&lt;= 小于或等于</span><br><span class="line">== 等于</span><br><span class="line">!= 不等于</span><br><span class="line">&gt; 大于</span><br><span class="line">&gt;= 大于或等于</span><br><span class="line">~ 匹配正则表达式</span><br><span class="line">!~ 不匹配正则表达式</span><br></pre></td></tr></table></figure><p>使用 if 指令判断来实现上面同样的效果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;&#123;if ($3 &lt; 5500) print $0&#125;&apos; company.txt</span><br><span class="line">yahoo   100 4500</span><br><span class="line">twitter 120 5000</span><br></pre></td></tr></table></figure></p><p>上面表示如果第 3 列字段小于 5500 的时候就会执行后面的 print $0，很像 C 语言和 PHP 的语法对不对。 想到这里有一句话不知当讲不当讲，那就是 PHP 是世界上最好的语言。</p><h4 id="在-awk-中使用正则表达式"><a href="#在-awk-中使用正则表达式" class="headerlink" title="在 awk 中使用正则表达式"></a>在 awk 中使用正则表达式</h4><p> 在 awk 中支持正则表达式的使用，如果你还对正则表达式不是很了解，请先停下来，上 google 去搜一下。</p><p>比如现在我们有这么一个文件 poetry.txt 里面都是我写的诗，不要问我为什么那么的有才华。内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This above all: to thine self be true</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br><span class="line">There’s a special providence in the fall of a sparrow</span><br><span class="line">No matter how dark long, may eventually in the day arrival</span><br></pre></td></tr></table></figure></p><p>使用正则表达式匹配字符串 “There” ，将包含这个字符串的行打印并输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/There/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br><span class="line">There’s a special providence in the fall of a sparrow</span><br></pre></td></tr></table></figure></p><p>使用正则表达式配一个包含字母 t 和字母 e ，并且 t 和 e 中间只能有任意单个字符的行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/t.e/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br><span class="line">There’s a special providence in the fall of a sparrow</span><br><span class="line">No matter how dark long, may eventually in the day arrival</span><br></pre></td></tr></table></figure></p><p>如果只想匹配单纯的字符串 “t.e”， 那正则表达式就是这样的 /t.e/ ，用反斜杠来转义 . 符号 因为 . 在正则表达式里面表示任意单个字符。</p><p>使用正则表达式来匹配所有以 “The” 字符串开头的行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/^The/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br><span class="line">There’s a special providence in the fall of a sparrow</span><br></pre></td></tr></table></figure></p><p>在正则表达式中 ^ 表示以某某字符或者字符串开头。</p><p>使用正则表达式来匹配所有以 “true” 字符串结尾的行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/true$/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">This above all: to thine self be true</span><br></pre></td></tr></table></figure></p><p>在正则表达式中 $ 表示以某某字符或者字符串结尾。</p><p>又一个正则表达式例子如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/m[a]t/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">No matter how dark long, may eventually in the day arrival</span><br></pre></td></tr></table></figure></p><p>上面这个正则表达式 /m[a]t/ 表示匹配包含字符 m ，然后接着后面还要包含中间方括号中表示的单个字符 a ，最后还要包含字符 t 的行，输出结果中只有单词 “matter” 符合这个正则表达式的匹配。因为正则表达式 [a] 方括号中表示匹配里面的任意单个字符。</p><p>继续上面的一个新例子如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/^Th[ie]/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">This above all: to thine self be true</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br><span class="line">There’s a special providence in the fall of a sparrow</span><br></pre></td></tr></table></figure></p><p>这个例子中的正则表达式 /^Th[ie]/表示匹配以字符串 “Thi” 或者 “The” 开头的行，正则表达式方括号中表示匹配其中的任意单个字符。</p><p> 再继续上面的新的用法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/s[a-z]/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">This above all: to thine self be true</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br><span class="line">There’s a special providence in the fall of a sparrow</span><br></pre></td></tr></table></figure></p><p>正则表达式 /s[a-z]/ 表示匹配包含字符 s 然后后面跟着任意 a 到 z 之间的单个字符的字符串，比如 “se”, “so”, “sp” 等等。</p><p> 正则表达式 [] 方括号中还有一些其他用法比如下面这些</p><p>[a-zA-Z]  表示匹配小写的 a 到 z 之间的单个字符，或者大写的 A 到 Z 之间的单个字符<br>[^a-z]    符号 <code>^</code> 在方括号里面表示取反，也就是非的意思，表示匹配任何非 a 到 z 之间的单个字符</p><p>正则表达式中的星号 * 和加号 + 的使用方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/go*d/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br></pre></td></tr></table></figure></p><p>上面这个表示匹配包含字符串 “god”，并且中间的字母 “o” 可以出现 0 次或者多次，比如单词 “good” 就符合这个要求。 正则表达式中的 + 和星号原理差不多，只是加号表示任意 1 个或者 1 个以上，也就是必须至少要出现一次。</p><p><strong>正则表达式问号 ? 的使用方法</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/ba?d/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br></pre></td></tr></table></figure></p><p>正则表达式中的问号 ? 表示它前面的字符只能出现 0 次 或者 1 次，也就是可以不出现，也可以出现，但如果有出现也最多只能出现 1 次。</p><p><strong>正则表达式中的 {} 花括号用法</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/go&#123;2&#125;d/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br></pre></td></tr></table></figure></p><p>花括号 {} 表示规定它前面的字符必须出现的次数，像上面这个 /go{2}d/ 就表示只匹配字符串 “good”，也就是中间的字母 “o” 必须要出现 2 次。</p><p><strong>正则表达式中的花括号还有一些其他的用法如下:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/go&#123;2,3&#125;d/    表示字母 &quot;o&quot; 只能可以出现 2 次或者 3 次</span><br><span class="line">/go&#123;2,10&#125;d/   表示字母 &quot;o&quot; 只能可以出现 2次，3次，4次，5次，6次 ... 一直到 10 次</span><br><span class="line">/go&#123;2,&#125;d/     表示字母 &quot;o&quot; 必须至少出现 2 次或着 2 次以上</span><br></pre></td></tr></table></figure></p><p><strong>正则表达式中的圆括号的用法</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &apos;/th(in)&#123;1&#125;king/&#123;print $0&#125;&apos; poetry.txt</span><br><span class="line">There is nothing either good or bad, but thinking makes it so</span><br></pre></td></tr></table></figure></p><p>正则表达式中的圆括号表示将多个字符当成一个完整的对象来看待。比如 /th(in){1}king/ 就表示其中字符串 “in” 必须出现 1 次。而如果不加圆括号就变成了 /thin{1}king/ 这个就表示其中字符 “n” 必须出现 1 次。</p><p>看到这里，如果你对 poetry.txt 件中写的诗比较熟悉，你就会发现。。。我去！这诗根本就不是我写的。所以论多读书是多么的重要。我有幸借用莎士比亚的诗来向你讲解如何在 awk 中使用正则表达式。</p><h4 id="使用-awk-的一些总结"><a href="#使用-awk-的一些总结" class="headerlink" title="使用 awk 的一些总结"></a>使用 awk 的一些总结</h4><p>因为 awk 算起来也是一种编程语言，它的功能远远不止我们上面讲的这些，awk 还有一些其他比较复杂的功能。但一般我们不建议将 awk 用的太过于复杂。通常面对一些比较复杂的场景我们还是要使用其他的一些工具，比如 shell 脚本，Lua 等等……</p><blockquote><p>原文来自：jarly<br><a href="https://my.oschina.net/jarly/blog/898144" target="_blank" rel="noopener">https://my.oschina.net/jarly/blog/898144</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;awk 是一个强大的文本分析工具。它不仅是 Linux 中，也是任何环境中现有的功能最强大的数据处理引擎之一。相对于 grep 的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3275724-417ad6ad01ebe66d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;small_Awk_command&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.yueyongblog.com/tags/Linux/"/>
    
      <category term="awk" scheme="https://www.yueyongblog.com/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令行：find的26个用法示例</title>
    <link href="https://www.yueyongblog.com/26-examples-of-find-command-on-linux.html"/>
    <id>https://www.yueyongblog.com/26-examples-of-find-command-on-linux.html</id>
    <published>2018-07-09T17:56:24.807Z</published>
    <updated>2018-07-11T09:32:42.824Z</updated>
    
    <content type="html"><![CDATA[<p>Linux系统中的 find 命令在查找文件时非常有用而且方便。它可以根据不同的条件来查找文件，例如权限、拥有者、修改日期/时间、文件大小等等。在这篇文章中，我们将学习如何使用 find 命令以及它所提供的选项来查找文件。</p><p><img src="https://upload-images.jianshu.io/upload_images/3275724-747df0725bdbd395.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="small_find_command.jpg"></p><a id="more"></a><p>在绝大多数Linux发行版中，你都可以直接使用 find 命令而无需进行任何安装操作。如果你想在linux系统的命令行中变得特别高效，那么 find 是你必须掌握的命令之一。</p><p>find 命令的基本语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find [path] [option] [expression]</span><br></pre></td></tr></table></figure></p><h4 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h4><h5 id="1-列出当前目录和子目录下的所有文件"><a href="#1-列出当前目录和子目录下的所有文件" class="headerlink" title="1.列出当前目录和子目录下的所有文件"></a>1.列出当前目录和子目录下的所有文件</h5><p>这个命令会列出当前目录以及子目录下的所有文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find</span><br><span class="line">.</span><br><span class="line">./abc.txt</span><br><span class="line">./subdir</span><br><span class="line">./subdir/how.php</span><br><span class="line">./cool.php</span><br></pre></td></tr></table></figure></p><p>该命令与以下命令效果相同<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find .</span><br><span class="line">$ find . -print</span><br></pre></td></tr></table></figure></p><h5 id="2-查找特殊的目录或路径"><a href="#2-查找特殊的目录或路径" class="headerlink" title="2. 查找特殊的目录或路径"></a>2. 查找特殊的目录或路径</h5><p>下面的命令会查找当前目录下 test 文件夹中的文件，默认列出所有文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test</span><br><span class="line">./test</span><br><span class="line">./test/abc.txt</span><br><span class="line">./test/subdir</span><br><span class="line">./test/subdir/how.php</span><br><span class="line">./test/cool.php</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>下面的命令用于查找指定名称的文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test -name &quot;abc.txt&quot;</span><br><span class="line">./test/abc.txt</span><br></pre></td></tr></table></figure></p><p>也可以使用通配符<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test -name &quot;*.php&quot;</span><br><span class="line">./test/subdir/how.php</span><br><span class="line">./test/cool.php</span><br></pre></td></tr></table></figure></p><p>请注意，所有的文件夹都会被递归地查找。所以，这是用于查找指定扩展名文件的一种非常强大的方式。</p><p>如果我们尝试搜索 / 文件夹，也就是根目录，就会搜索整个文件系统，包括挂载的设备以及网络存储设备。所以请小心使用。当然，你随时可以通过按 Ctrl + C 来终止命令。</p><p>注意：当指定文件夹的时候（例如示例中的”./test”文件夹），忽略末尾的斜杠是没有问题的。但是，如果文件夹是一个指向其它位置的链接（symlink）时，你必须在末尾写上斜杠才能使find命令正常工作（find ./test/）。</p><h5 id="忽略大小写"><a href="#忽略大小写" class="headerlink" title="忽略大小写"></a>忽略大小写</h5><p>在查找文件名时，忽略大小写往往非常有用。要忽略大小写，只需要使用 iname 选项，而不是 name 选项。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test -iname &quot;*.Php&quot;</span><br><span class="line">./test/subdir/how.php</span><br><span class="line">./test/cool.php</span><br></pre></td></tr></table></figure></p><p>总是用双引号或单引号来包围匹配模式（文件名参数），这非常有用。不这样做的话有时也能正常工作，有时也可能会产生奇怪的结果。</p><h5 id="3-限制目录查找的深度"><a href="#3-限制目录查找的深度" class="headerlink" title="3. 限制目录查找的深度"></a>3. 限制目录查找的深度</h5><p>find 命令默认会递归查找整个目录树，而这非常消耗时间和资源。好在目录查找的深度可以手动指定。例如我们只想查找一到两层以内的子目录，可以通过 maxdepth 选项来指定。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test -maxdepth 2 -name &quot;*.php&quot;</span><br><span class="line">./test/subdir/how.php</span><br><span class="line">./test/cool.php</span><br><span class="line"></span><br><span class="line">$ find ./test -maxdepth 1 -name *.php</span><br><span class="line">./test/cool.php</span><br></pre></td></tr></table></figure></p><p>第二个示例中指定了 maxdepth 为1，表明最多只查找一层内的子目录，也就是只查找当前文件夹。</p><p>当我们只想在当前目录下查找，而不是查找整个目录树的时候，这个选项会特别有用。</p><p>与 maxdepth 选项相似，还有一个选项叫做 mindepth ，正如名字所表示的那样，它会至少到达第 N 层子目录后才开始查找文件。</p><h5 id="4-反向查找"><a href="#4-反向查找" class="headerlink" title="4. 反向查找"></a>4. 反向查找</h5><p>除了查找满足条件的文件之外，我们还可以查找不满足条件的所有文件。当我们知道要在查找中排除哪些文件时，这个选项就能发挥作用了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test -not -name &quot;*.php&quot;</span><br><span class="line">./test</span><br><span class="line">./test/abc.txt</span><br><span class="line">./test/subdir</span><br></pre></td></tr></table></figure></p><p>在上面的示例中我们找到了所有扩展名不是 php 的文件和文件夹。我们也可以使用感叹号 ! 来代替 -not。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ./test ! -name &quot;*.php&quot;</span><br></pre></td></tr></table></figure></p><h5 id="5-结合多个查找条件"><a href="#5-结合多个查找条件" class="headerlink" title="5. 结合多个查找条件"></a>5. 结合多个查找条件</h5><p>我们可以同时使用多个查找条件来指定文件名并排除某些文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test -name &apos;abc*&apos; ! -name &apos;*.php&apos;</span><br><span class="line">./test/abc.txt</span><br><span class="line">./test/abc</span><br></pre></td></tr></table></figure></p><p>上面的命令查找所有以 abc 开头并且不含 .php 扩展名的文件。这个示例展现了 find 命令自带的查找表达式是多么的强大。</p><h4 id="OR-操作符"><a href="#OR-操作符" class="headerlink" title="OR 操作符"></a>OR 操作符</h4><p>当我们使用多个查找条件时， find 命令会将它们通过 AND 操作符结合起来，也就是说，只有满足所有条件的文件才会被列出。不过，如果我们需要进行基于 OR 运算的查找时，可以加上 -o 开关。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find -name &apos;*.php&apos; -o -name &apos;*.txt&apos;</span><br><span class="line">./abc.txt</span><br><span class="line">./subdir/how.php</span><br><span class="line">./abc.php</span><br><span class="line">./cool.php</span><br></pre></td></tr></table></figure></p><p>上面的命令查找所有以 .php 结尾或者以 .txt 结尾的文件。</p><h5 id="6-只查找文件或目录"><a href="#6-只查找文件或目录" class="headerlink" title="6. 只查找文件或目录"></a>6. 只查找文件或目录</h5><p>有时我们只想通过某个名字查找对应的文件或对应的目录，我们可以很容易实现这个要求。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test -name abc*</span><br><span class="line">./test/abc.txt</span><br><span class="line">./test/abc</span><br></pre></td></tr></table></figure></p><p><strong>只查找文件</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test -type f -name &quot;abc*&quot;</span><br><span class="line">./test/abc.txt</span><br></pre></td></tr></table></figure></p><p><strong>只查找目录</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test -type d -name &quot;abc*&quot;</span><br><span class="line">./test/abc</span><br></pre></td></tr></table></figure></p><p>非常有用而且方便！</p><h5 id="7-同时在多个目录下查找"><a href="#7-同时在多个目录下查找" class="headerlink" title="7. 同时在多个目录下查找"></a>7. 同时在多个目录下查找</h5><p>如果你想要在两个不同的目录内进行查找，命令非常简单。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./test ./dir2 -type f -name &quot;abc*&quot;</span><br><span class="line">./test/abc.txt</span><br><span class="line">./dir2/abcdefg.txt</span><br></pre></td></tr></table></figure></p><p>检查一下，它确实列出了来自给定的两个目录的文件。</p><h5 id="8-查找隐藏文件"><a href="#8-查找隐藏文件" class="headerlink" title="8. 查找隐藏文件"></a>8. 查找隐藏文件</h5><p>在Linux系统中，隐藏文件的名字以英文的句号开头，即 . 。所以要列出隐藏文件，只需加上简单的文件名过滤条件就行了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ~ -type f -name &quot;.*&quot;</span><br></pre></td></tr></table></figure></p><p>####二、基于文件权限和属性的查找</p><p>######9. 查找指定权限的文件</p><p>通过指定 perm 选项，我们可以查找具有特定权限的文件。下面的示例中查找了所有具有 0664 权限的文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -type f -perm 0664</span><br><span class="line">./abc.txt</span><br><span class="line">./subdir/how.php</span><br><span class="line">./abc.php</span><br><span class="line">./cool.php</span><br></pre></td></tr></table></figure></p><p>我们可以用这个命令来查找带有错误权限的文件，这些文件可能会产生安全问题。</p><p>可以结合 反向查找 来进行权限检查。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -type f ! -perm 0777</span><br><span class="line">./abc.txt</span><br><span class="line">./subdir/how.php</span><br><span class="line">./abc.php</span><br><span class="line">./cool.php</span><br></pre></td></tr></table></figure></p><h5 id="10-查找具有-SGID-SUID-属性的文件"><a href="#10-查找具有-SGID-SUID-属性的文件" class="headerlink" title="10. 查找具有 SGID/SUID 属性的文件"></a>10. 查找具有 SGID/SUID 属性的文件</h5><p>下面的命令查找所有具有 644 权限和 SGID 属性的文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find / -perm 2644</span><br></pre></td></tr></table></figure></p><p>我们同样可以使用 1664 来查找设置了 粘滞位 （sticky bit）的文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find / -perm 1644</span><br></pre></td></tr></table></figure></p><p>perm 选项除了接受数值型参数外，同样接受 chmod 命令中的模式串。在下面的查找中，我们用另一种语法来代替数字。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find / -maxdepth 2 -perm /u=s 2&gt;/dev/null</span><br><span class="line">/bin/mount</span><br><span class="line">/bin/su</span><br><span class="line">/bin/ping6</span><br><span class="line">/bin/fusermount</span><br><span class="line">/bin/ping</span><br><span class="line">/bin/umount</span><br><span class="line">/sbin/mount.ecryptfs_private</span><br></pre></td></tr></table></figure></p><p>注意：由于权限不足，某些目录会拒接访问。命令中的 2&gt;/dev/null 正是用于清除输出中的错误访问结果。</p><h5 id="11-查找只读文件"><a href="#11-查找只读文件" class="headerlink" title="11. 查找只读文件"></a>11. 查找只读文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find /etc -maxdepth 1 -perm /u=r</span><br><span class="line">/etc</span><br><span class="line">/etc/thunderbird</span><br><span class="line">/etc/brltty</span><br><span class="line">/etc/dkms</span><br><span class="line">/etc/phpmyadmin</span><br><span class="line">... output truncated ...</span><br></pre></td></tr></table></figure><h5 id="12-查找可执行文件"><a href="#12-查找可执行文件" class="headerlink" title="12. 查找可执行文件"></a>12. 查找可执行文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find /bin -maxdepth 2 -perm /a=x</span><br><span class="line">/bin</span><br><span class="line">/bin/preseed_command</span><br><span class="line">/bin/mount</span><br><span class="line">/bin/zfgrep</span><br><span class="line">/bin/tempfile</span><br><span class="line">... output truncated ...</span><br></pre></td></tr></table></figure><h4 id="三、基于文件拥有者和用户组的查找"><a href="#三、基于文件拥有者和用户组的查找" class="headerlink" title="三、基于文件拥有者和用户组的查找"></a>三、基于文件拥有者和用户组的查找</h4><h5 id="13-查找属于特定用户的文件"><a href="#13-查找属于特定用户的文件" class="headerlink" title="13. 查找属于特定用户的文件"></a>13. 查找属于特定用户的文件</h5><p>查找当前目录下，属于 bob 的文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -user bob</span><br><span class="line">.</span><br><span class="line">./abc.txt</span><br><span class="line">./abc</span><br><span class="line">./subdir</span><br><span class="line">./subdir/how.php</span><br><span class="line">./abc.php</span><br></pre></td></tr></table></figure></p><p>在指定所属用户的同时，我们同样可以指定文件名。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -user bob -name &apos;*.php&apos;</span><br></pre></td></tr></table></figure></p><p>很容易看出，我们可以通过增加过滤条件来缩小查找文件的范围。</p><h5 id="14-查找属于特定用户组的文件"><a href="#14-查找属于特定用户组的文件" class="headerlink" title="14. 查找属于特定用户组的文件"></a>14. 查找属于特定用户组的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find /var/www -group developer</span><br></pre></td></tr></table></figure><h4 id="四、基于日期和时间的查找"><a href="#四、基于日期和时间的查找" class="headerlink" title="四、基于日期和时间的查找"></a>四、基于日期和时间的查找</h4><p>除了上面介绍的查找条件外，另外一个非常棒的查找条件就是文件的修改和访问时间（日期）。当我们想要找出哪些文件在某段时间内被修改的时候，这个查找条件将会非常方便。我们来看几个例子。</p><h5 id="15-查找过去的第-N-天被修改过的文件"><a href="#15-查找过去的第-N-天被修改过的文件" class="headerlink" title="15. 查找过去的第 N 天被修改过的文件"></a>15. 查找过去的第 N 天被修改过的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find / -mtime 50</span><br></pre></td></tr></table></figure><h5 id="16-查找过去的-N-天内被访问过的文件"><a href="#16-查找过去的-N-天内被访问过的文件" class="headerlink" title="16. 查找过去的 N 天内被访问过的文件"></a>16. 查找过去的 N 天内被访问过的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find / -atime -50</span><br></pre></td></tr></table></figure><h5 id="17-查找某段时间范围内被修改过内容的文件"><a href="#17-查找某段时间范围内被修改过内容的文件" class="headerlink" title="17. 查找某段时间范围内被修改过内容的文件"></a>17. 查找某段时间范围内被修改过内容的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find / -mtime +50 -mtime -100</span><br></pre></td></tr></table></figure><h5 id="18-查找过去的-N-分钟内状态发生改变的文件"><a href="#18-查找过去的-N-分钟内状态发生改变的文件" class="headerlink" title="18. 查找过去的 N 分钟内状态发生改变的文件"></a>18. 查找过去的 N 分钟内状态发生改变的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find /home/bob -cmin -60</span><br></pre></td></tr></table></figure><h5 id="19-查找过去的-1-小时内被修改过内容的文件"><a href="#19-查找过去的-1-小时内被修改过内容的文件" class="headerlink" title="19. 查找过去的 1 小时内被修改过内容的文件"></a>19. 查找过去的 1 小时内被修改过内容的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find / -mmin -60</span><br></pre></td></tr></table></figure><h5 id="20-查找过去的-1-小时内被访问过的文件"><a href="#20-查找过去的-1-小时内被访问过的文件" class="headerlink" title="20. 查找过去的 1 小时内被访问过的文件"></a>20. 查找过去的 1 小时内被访问过的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find / -amin -60</span><br></pre></td></tr></table></figure><h4 id="五、基于文件大小的查找"><a href="#五、基于文件大小的查找" class="headerlink" title="五、基于文件大小的查找"></a>五、基于文件大小的查找</h4><h5 id="21-查找指定大小的文件"><a href="#21-查找指定大小的文件" class="headerlink" title="21. 查找指定大小的文件"></a>21. 查找指定大小的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find / -size 50M</span><br></pre></td></tr></table></figure><h5 id="22-查找大小在一定范围内的文件"><a href="#22-查找大小在一定范围内的文件" class="headerlink" title="22. 查找大小在一定范围内的文件"></a>22. 查找大小在一定范围内的文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find / -size +50M -size -100M</span><br></pre></td></tr></table></figure><h5 id="23-查找最大和最小的文件"><a href="#23-查找最大和最小的文件" class="headerlink" title="23. 查找最大和最小的文件"></a>23. 查找最大和最小的文件</h5><p>我们可以将 find 命令与 ls 和 sort命令结合，从而找出最大或最小的文件。</p><p>下面的命令使用了 sort 命令的 -r 选项，也就是从大到小降序排列。经过 head 命令的过滤之后，会显示当前目录和子目录下最大的5个文件。命令的执行过程需要一段时间，查找的速度取决于文件的总数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -type f -exec ls -s &#123;&#125; \; | sort -n -r | head 5</span><br></pre></td></tr></table></figure></p><p>同样，我们可以去掉 sort 命令的 -r 选项来进行升序排列，从而显示出最小的5个文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -type f -exec ls -s &#123;&#125; \; | sort -n | head 5</span><br></pre></td></tr></table></figure></p><h5 id="24-查找空文件和空目录"><a href="#24-查找空文件和空目录" class="headerlink" title="24. 查找空文件和空目录"></a>24. 查找空文件和空目录</h5><p>查找空文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find /tmp -type f -empty</span><br></pre></td></tr></table></figure></p><p>查找空目录：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ~/ -type d -empty</span><br></pre></td></tr></table></figure></p><p>非常简单！</p><h4 id="六、高级操作"><a href="#六、高级操作" class="headerlink" title="六、高级操作"></a>六、高级操作</h4><p>find 命令不仅可以通过特定条件来查找文件，还可以对查找到的文件使用任意linux命令进行操作。下面给出两个例子。</p><h5 id="25-使用-ls-命令列出文件信息"><a href="#25-使用-ls-命令列出文件信息" class="headerlink" title="25. 使用 ls 命令列出文件信息"></a>25. 使用 ls 命令列出文件信息</h5><p>我们使用 find 命令找到文件后，只能看到文件路径。如果想进一步查看文件信息，可以结合 ls 命令来实现。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find . -exec ls -ld &#123;&#125; \;</span><br><span class="line">drwxrwxr-x 4 enlightened enlightened 4096 Aug 11 19:01 .</span><br><span class="line">-rw-rw-r-- 1 enlightened enlightened 0 Aug 11 16:25 ./abc.txt</span><br><span class="line">drwxrwxr-x 2 enlightened enlightened 4096 Aug 11 16:48 ./abc</span><br><span class="line">drwxrwxr-x 2 enlightened enlightened 4096 Aug 11 16:26 ./subdir</span><br><span class="line">-rw-rw-r-- 1 enlightened enlightened 0 Aug 11 16:26 ./subdir/how.php</span><br><span class="line">-rw-rw-r-- 1 enlightened enlightened 29 Aug 11 19:13 ./abc.php</span><br><span class="line">-rw-rw-r-- 1 enlightened enlightened 0 Aug 11 16:25 ./cool.php</span><br></pre></td></tr></table></figure></p><h5 id="26-删除找到的文件"><a href="#26-删除找到的文件" class="headerlink" title="26. 删除找到的文件"></a>26. 删除找到的文件</h5><p>下面的命令会删除 tmp 目录下扩展名为 .txt 的文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find /tmp -type f -name &quot;*.txt&quot; -exec rm -f &#123;&#125; \;</span><br></pre></td></tr></table></figure></p><p>我们同样可以删除目录，只要把 -type 后面的 f 改为 d ，并且在 rm 命令后面加上 -r 即可。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find /tmp -type d -name &quot;dirToRemove&quot; -exec rm -r -f &#123;&#125; \;</span><br></pre></td></tr></table></figure></p><p><strong>原文来自：<a href="http://www.codebelief.com/article/2017/02/26-examples-of-find-command-on-linux/" target="_blank" rel="noopener">http://www.codebelief.com/article/2017/02/26-examples-of-find-command-on-linux/</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux系统中的 find 命令在查找文件时非常有用而且方便。它可以根据不同的条件来查找文件，例如权限、拥有者、修改日期/时间、文件大小等等。在这篇文章中，我们将学习如何使用 find 命令以及它所提供的选项来查找文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3275724-747df0725bdbd395.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;small_find_command.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.yueyongblog.com/tags/Linux/"/>
    
      <category term="find" scheme="https://www.yueyongblog.com/tags/find/"/>
    
  </entry>
  
  <entry>
    <title>Markdown的常用语法总结</title>
    <link href="https://www.yueyongblog.com/Markdown-use.html"/>
    <id>https://www.yueyongblog.com/Markdown-use.html</id>
    <published>2018-05-29T16:23:44.070Z</published>
    <updated>2018-06-29T07:58:03.453Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3275724-090129e5e0ae2657.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><h4 id="Markdown是什么？"><a href="#Markdown是什么？" class="headerlink" title="Markdown是什么？"></a>Markdown是什么？</h4><p>Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 其中最重要的设计是可读性，也就是说这个语言应该要能直接在字面上的被阅读，而不用被一些格式化指令标记(像是 RTF 与 HTML)。</p><p>下面总结一下Markdown常用的基础语法，让你快速掌握，并运用。</p><h4 id="Markdown的优点："><a href="#Markdown的优点：" class="headerlink" title="Markdown的优点："></a>Markdown的优点：</h4><p>1.纯文本，所以兼容性极强，可以用所有文本编辑器打开。<br>2.让你专注于文字而不是排版。<br>3.格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。<br>4.Markdown 的标记语法有极好的可读性。</p><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题             //表示是一级标题或使用&lt;h1&gt;</span><br><span class="line">## 二级标题            //表示是二级标题或使用&lt;h2&gt;</span><br><span class="line">### 三级标题           //表示是三级标题或使用&lt;h3&gt;</span><br><span class="line">#### 四级标题          //表示是四级标题或使用&lt;h4&gt;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>在所需的文字前面加上<code>#</code>号和空格符，注意<code>#</code>号后面的空格，也可以使用HTML代码表示标题，这里不详解。</p><h4 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h4><p>用一个<code>*</code>或者<code>_</code>包含起来表示斜体；<br>显示效果如下：<br><em>强调</em>  或者  _强调_</p><p>用两个<code>**</code> 和<code>__</code>包含起来表示粗体；<br>显示效果如下：<br><strong>加重强调</strong> 或者 <strong>加重强调</strong></p><p>用三个<code>***</code> 或者<code>___</code>表示粗斜体；<br>显示效果如下：<br><strong><em>强调</em></strong>  <strong>_强调_</strong></p><p>使用两个<code>~~</code>表示删除；<br><del>删除</del></p><h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><p>在Markdown中，插入链接直接使用<code>[显示文本](链接地址)</code>这样的语法即可，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[YueYong&apos;s Blog](http://yueyongblog.com)</span><br></pre></td></tr></table></figure></p><p>显示效果如下：<br><a href="http://yueyongblog.com" target="_blank" rel="noopener">YueYong’s Blog</a></p><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p>插入图片使用<code>![](图片链接地址)</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![这里描述信息](http://upload-images.jianshu.io/upload_images/3275724-8fea54b4fef2cec2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br></pre></td></tr></table></figure></p><p>显示效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/3275724-8fea54b4fef2cec2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表格式也很常用，只需要在文字前面加上<code>-</code> 就可以了，例如：</p><p><strong>无序列表：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 文本1</span><br><span class="line">- 文本2</span><br><span class="line">- 文本3</span><br></pre></td></tr></table></figure></p><p>显示效果如下：</p><ul><li>文本1</li><li>文本2</li><li>文本3</li></ul><p><strong>有序列表：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 文本1</span><br><span class="line">2. 文本2</span><br><span class="line">3. 文本3</span><br></pre></td></tr></table></figure></p><p>显示效果如下：<br>1.文本1<br>2.文本2<br>3.文本3</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>在写作的过程中会引用别人的文字，或者在文章末尾用到，需要在文章前面加上<code>&gt;</code>和空格字符就好了。</p><p>显示效果如下：</p><blockquote><p>人生如梦，岁月无情，豁然回首，才发现人活着是一种心情，穷也好，富也好；得也好，失也好，一切都是过眼云烟。想想不管昨天、今天、明天。能豁然开朗就是美好的一天。不管亲情，友情，爱情。能永远珍惜就是好心情。记得有位朋友说过这样的话：“曾经拥有的不要忘记，已经得到的更加珍惜，属于自己的不要放弃，已经失去的留作回忆，想要得到，一定要努力。</p></blockquote><h4 id="代码块的引用"><a href="#代码块的引用" class="headerlink" title="代码块的引用"></a>代码块的引用</h4><p>当编写代码时,需要时代码的引用，使用三个<code>```</code>,table上面那个按键，<br>还可以单独使用一个<code>`</code> 包含需要的文字或单词、代码等；<br>显示效果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello world!</span><br><span class="line">Life is short, I learn python</span><br><span class="line">This is YueYong&apos;s blog</span><br></pre></td></tr></table></figure><p><code>world</code></p><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>在编写一段文字的时候，需要另起一段，使用Eenter按键直接换行，或者使用<code>br</code>标签</p><h4 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h4><p>可以在单独一行里输入3个或以上的短横线、星号或者下划线均可实现；<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * *</span><br><span class="line">***</span><br><span class="line">*****</span><br><span class="line">- - -</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure></p><p>显示效果如下：</p><hr><hr><h4 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表:"></a>任务列表:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-  [x] 任务1，已完成;</span><br><span class="line">-  [x] 任务2，已完成;</span><br><span class="line">-  [ ] 任务3，未完成;</span><br></pre></td></tr></table></figure><p>显示效果如下：</p><ul><li style="list-style: none"><input type="checkbox" checked> 任务1，已完成;</li><li style="list-style: none"><input type="checkbox" checked> 任务2，已完成;</li><li style="list-style: none"><input type="checkbox"> 任务3，未完成;</li></ul><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>:— 表示居左，即默认格式， :—: 表示居中，—: 表示居右；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 姓名| 性别 | 年龄 |</span><br><span class="line">|:-----|:-----:|-----:|</span><br><span class="line">| 张三 | 男   | 18 |</span><br><span class="line">| 李四 | 女   | 17 |</span><br></pre></td></tr></table></figure><p>显示效果如下：</p><table><thead><tr><th style="text-align:left">姓名</th><th style="text-align:center">性别</th><th style="text-align:right">年龄</th></tr></thead><tbody><tr><td style="text-align:left">张三</td><td style="text-align:center">男</td><td style="text-align:right">18</td></tr><tr><td style="text-align:left">李四</td><td style="text-align:center">女</td><td style="text-align:right">17</td></tr></tbody></table><p><br></p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="http://www.jianshu.com/p/q81RER#" target="_blank" rel="noopener">献给写作者的 Markdown 新手指南</a><br><a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">Markdown 语法说明 (简体中文版)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3275724-090129e5e0ae2657.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Markdown" scheme="https://www.yueyongblog.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Hello World —— My Blog！</title>
    <link href="https://www.yueyongblog.com/hello-blog.html"/>
    <id>https://www.yueyongblog.com/hello-blog.html</id>
    <published>2018-05-29T15:49:56.306Z</published>
    <updated>2018-06-29T12:56:41.328Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="security">  <div class="input-container">  <input type="password" class="form-control" id="pass" placeholder="请输入文章密码" />    <label for="pass">请输入文章密码</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      欢迎您来我的小窝，终于抽空把博客搭建好了……
    
    </summary>
    
    
      <category term="随笔" scheme="https://www.yueyongblog.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
